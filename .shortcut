#!/bin/sh

##### Automatic variable #####
#		 !:0 = the name of command executed.
#		 !:1 = the first parameter of the previous command
#		 !:4 = the fourth parameter of the previous command
#		 !:* = all of the parameters of the previous command
#		 !^ = the first parameter of the previous command (same as !:1)
#		 !$ = the final parameter of the previous command
#		 !:-3 = all parameters in range 0-3 (inclusive)
#		 !:2-5 = all parameters in range 2-5 (inclusive)
#		 !! = the previous command line

##### COLORS #####

function mini()
{
	cmd="cd ~/mini_mael/minishell/minishell && clear "

	h=""
	m=""
	g=""
	v=""
	# big=$1
	# needle="m"
	if [[ $# -ge 1 ]]
	then
		if [[ "${1/'g'}" != $1 && "${1/'v'}" != $1 ]]
		then
			echo -e $RED"something wrong"$RST
			exit 0
		fi
		if [[ "${1/'h'}" != $1 ]]
		then
			h=" && hcreate "
		fi
		if [[ "${1/'m'}" != $1 ]]
		then
			m=" && make re"
		else
			m=" && make"
		fi
		if [[ "${1/'v'}" != $1 && "${1/'g'}" == $1 ]]
		then
			v="valgrind --suppressions=./leak.txt --leak-check=full --show-leak-kinds=all --track-origins=yes --track-fds=yes "
		elif [[ "${1/'g'}" != $1 && "${1/'v'}" == $1 ]]
		then
			g="gdb"
		fi
	fi
	if [[ $# == 1 ]]
	then
		total=$cmd$h$m" && clear && "$v$g" ./minishell"
		eval $total
		echo
		echo $total
		echo
	elif [[ $# == 2 ]]
	then
		total=$cmd$h$m" && clear && echo -e \"$2\" | "$v$g" ./minishell"
		eval $total
		echo
		echo $total
		echo
	elif [[ $# == 0 ]]
	then
		total=$cmd" && make && ./minishell "
		eval $total
	fi
}

function osco()
{
	if [[ $# == 1 ]]
	then
		cd ~/osco_sh && make && echo "ls | grep i | grep n | wc -l | wc -m " | ./minishell
	else
		cd ~/osco_sh && make && ./minishell
	fi
}

function mathieu()
{
	if [[ $# == 1 ]]
	then
		cd ~/mathieu_sh && make && echo "ls | grep i | grep n | wc -l | wc -m " | ./minishell
	else
		cd ~/mathieu_sh && make && ./minishell
	fi
}

# lite
export BLACK="\033[0;30m"
export RED="\033[0;31m"
export GREEN="\033[0;32m"
export YELLOW="\033[0;33m"
export BLUE="\033[0;34m"
export PURPLE="\033[0;35m"
export CYAN="\033[0;36m"
export WHITE="\033[0;37m"

# bold color
export BOLD_BLACK="\033[1;30m"
export BOLD_RED="\033[1;31m"
export BOLD_GREEN="\033[1;32m"
export BOLD_YELLOW="\033[1;33m"
export BOLD_BLUE="\033[1;34m"
export BOLD_PURPLE="\033[1;35m"
export BOLD_CYAN="\033[1;36m"
export BOLD_WHITE="\033[1;37m"

# background
export BACK_BLACK="\033[0;40m"
export BACK_RED="\033[0;41;30m"
export BACK_GREEN="\033[0;42;30m"
export BACK_YELLOW="\033[0;43;30m"
export BACK_BLUE="\033[0;44;30m"
export BACK_PURPLE="\033[0;45;30m"
export BACK_CYAN="\033[0;46;30m"
export BACK_WHITE="\033[0;47;30m"

# bold & background
export BOLD_BACK_BLACK="\033[1;40m"
export BOLD_BACK_RED="\033[1;41;30m"
export BOLD_BACK_GREEN="\033[1;42;30m"
export BOLD_BACK_YELLOW="\033[1;43;30m"
export BOLD_BACK_BLUE="\033[1;44;30m"
export BOLD_BACK_PURPLE="\033[1;45;37m"
export BOLD_BACK_CYAN="\033[1;46;30m"
export BOLD_BACK_WHITE="\033[1;47;30m"

# underline color
export UNDERLINE_BLACK="\033[4;30m"
export UNDERLINE_RED="\033[4;31m"
export UNDERLINE_GREEN="\033[4;32m"
export UNDERLINE_YELLOW="\033[4;33m"
export UNDERLINE_BLUE="\033[4;34m"
export UNDERLINE_PURPLE="\033[4;35m"
export UNDERLINE_CYAN="\033[4;36m"
export UNDERLINE_WHITE="\033[4;37m"

export RST="\033[0m"

export NOTHING="$BOLD_YELLOW""nothing happened üëí$RST"
export W_ARGS="$RED""wrong numbers of args$RST"

# bind -s 'set completion-ignore-case on'

SLEEP=2

# alias norminette='norminette -R CheckForbiddenSourceHeader'
# alias norminette='norminette | awk '\''{gsub(/OK/,"\033[1;32mOK\033[0m");}1'\'' | awk '\''{gsub(/Error!/,"\033[1;31mError!\033[0m");}1'\'
alias norm='norminette | grep -vi ok'
alias gcw='gcc -Wall -Wextra -Werror -g'

alias gcl='git clone'

alias ..='cd ..'
alias c='clear'
alias l='ls'
alias grep='grep --color=always --binary-files=without-match'
alias env+='env -0 | sort -z | tr "\0" "\n"'

# alias set_rc='cp -f ~/42/.shortcut ~/.'
# alias get_rc='cp -f ~/.shortcut ~/42/.'

shell_name=$(ps -p $$ | tail -n 1 | awk '{print $4}')
# shell_name=$(ps -ef | grep $$ | grep -v grep | head -1 | awk '{print $8}')
exe_name="pipex"
CC="gcc -Wall -Wextra -Werror -o $exe_name"
input_file="./$exe_name"

function ld()
{
	actual_path=$(pwd)/*
	for file in $actual_path
	do
		dir="$(dirname "${file}")"
		dirname="$(basename "${file}")"
		if [[ -d $file ]]; then
			echo -e "$CYAN ./$dirname"
		fi
	done
}

function lf()
{
	actual_path=$(pwd)/*
	for file in $actual_path
	do
		dir="$(dirname "${file}")"
		filename="$(basename "${file}")"
		if [[ -f $file ]]; then
			echo -e "$GREEN $filename"
		fi
	done
}

function updt()
{
	sudo snap refresh
	checkupdates
	if [[ $? -eq 0 ]]
	then
		sudo pacman-mirrors -f && sudo pacman -Syyu --noconfirm
	else
		echo -e $BOLD_WHITE"----- no package to update -----"$RST
	fi
	if [ $(ls 2>/dev/null ~/T√©l√©chargements/*mp3 | wc -l) -gt 0 ]
	then
		IFS=$'\n'
		music_list=($(ls ~/T√©l√©chargements/*mp3))
		nbr_music=$(ls ~/T√©l√©chargements/*mp3 | wc -l)
		mv ~/T√©l√©chargements/*mp3 ~/Musique/listen/.
		echo -e $BOLD_GREEN"-----  $nbr_music music updated    -----"$RST
		for val in "${music_list[@]}"
		do
			echo -e $GREEN"$(basename $val)"$RST
		done
	else
		echo -e $BOLD_WHITE"-----   music up to date   -----"$RST
	fi
}

function cron_edit()
{
	code ~/.updt.sh
	echo "for more: "
	echo "crontab -e"
}

function cfg()
{
	code ~/save_shortcut/.shortcut
	# a=$(pwd)
	# cd ~/42 && code 42/.shortcut
	# cd $a
}

function cfga()
{
	if [[ $shell_name == "zsh" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.zshrc" ]; then
			code ~/.zshrc
		fi
		if [ -f "/home/$USER/.zshrc" ]; then
			code ~/.zshrc
		fi
	fi
	if [[ $shell_name == "bash" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.bashrc" ]; then
			code ~/.bashrc
		fi
		if [ -f "/home/$USER/.bashrc" ]; then
			code ~/.bashrc
		fi
	fi
	code ~/save_shortcut/.shortcut
}

function cfg()
{
	code ~/shell_function_n_shortcuts/.shortcut
}

function start()
{
	if [[ $shell_name == "zsh" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.zshrc" ]; then
			source ~/.zshrc
			echo
			echo -e "\t "$BACK_CYAN" ZSH is restarted "$RST
			echo
		fi
		if [ -f "/home/$USER/.zshrc" ]; then
			source ~/.zshrc
			echo
			echo -e "\t "$BACK_CYAN" ZSH is restarted "$RST
			echo
		fi
	fi
	if [[ $shell_name == "bash" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.bashrc" ]; then
			source ~/.bashrc
			echo
			echo -e "\t "$BACK_CYAN" BASH is restarted "$RST
			echo
		fi
		if [ -f "/home/$USER/.bashrc" ]; then
			source ~/.bashrc
			echo
			echo -e "\t "$BACK_CYAN" BASH is restarted "$RST
			echo
		fi
	fi
}

function normi()
{
	norminette | grep -vi OK

	echo ""
	nbr_error=$(norminette | grep Error! | wc -l)
	nbr_ok=$(norminette | grep OK! | wc -l)
	nbr_total=0
	let "nbr_total=$nbr_error+$nbr_ok"
	res=$(echo "scale=2; $nbr_ok / $nbr_total *100" | bc )

	echo -ne "$BOLD_RED""Error: $nbr_error \t"$RST
	echo -ne "$BOLD_GREEN""OK: $nbr_ok  \t"$RST
	echo -ne "number of files: $BOLD_WHITE$nbr_total    \t\t"$RST
	echo -ne "perc: $BOLD_WHITE$res"
	echo " %"
}

# shortcut

function commit()
{
	if [[ $# == 1 ]]; then
		git status
		echo -e "$BACK_CYAN Start commit $RST"

		git add .
		git commit -a -m $1

		echo -e "$BACK_CYAN End commit $RST"
		git status
	else
		echo -e W_ARGS
	fi
}

function poush()
{
	if [[ $# == 1 ]]; then
		git status
		echo -e "$BACK_GREEN Start poush $RST"

		git add .
		git commit -a -m $1
		git push

		echo -e "$BACK_GREEN End poush $RST"
		git status
	else
		echo -e W_ARGS
	fi
}

function poush_42()
{
	if [[ $# == 1 ]]; then
		date
		save=$(pwd)
		cd ~/42
		# cp ~/.config/Code/User/snippets/c.json .
		# cp ~/.config/Code/User/snippets/shellscript.json .
		# cp -f ~/.shortcut .
		git status
		sleep 1.5
		echo -e $BACK_GREEN" Poush "$RST
		git add ~/42/.
		git commit -a -m $1
		git push
		echo -e $BACK_GREEN" End of Poush "$RST
		git status
		cd $save
	else
		echo "missing arg"
	fi
}

function pull_42()
{
	date
	if [[ $1 == "out" ]]
	then
		a=$(pwd)
		cd ~/42
		git pull
		cd $a
	else
		cd ~/42
		git pull
	fi
	# cp -f ~/42/c.json ~/.config/Code/User/snippets/
	# cp -f ~/42/shellscript.json ~/.config/Code/User/snippets/
}

function cpl()
{
	rm -f *.gch
	rm -f */*.gch
	$CC $@ && $input_file
}

function cpla()
{
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h && $input_file
		rm -f *.gch
		rm -f */*.gch
	else
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h && $input_file $@
		rm -f *.gch
		rm -f */*.gch
	fi

}

function cpl_all()
{
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file
		rm -f *.gch
		rm -f */*.gch
	else
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file $@
		rm -f *.gch
		rm -f */*.gch
	fi

}

function cplc()
{
	clear
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		$CC -g *.c *.h && $input_file
		rm -f *.gch
	else
		rm -f *.gch
		$CC -g *.c *.h && $input_file $@
		rm -f *.gch
	fi

}

function cplc_all()
{
	clear
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file
		rm -f *.gch
		rm -f */*.gch
	else
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file $@
		rm -f *.gch
		rm -f */*.gch
	fi
}

# if [ "${1/-*s}" != $1 ]; then
# 	$CC -D BUFFER_SIZE=42 *.c *.h */*.c */*.h && $input_file
# else
# 	$CC -D BUFFER_SIZE=42 *.c *.h && $input_file
# fi

# with args
function refresh()
{
	if [[ "$#" > 0 ]]; then
		while true; do
			tput clear
			tput cup 0 0
			echo -e $BACK_CYAN" ----- START ----- "$RST"\n"
			rm -f *.gch
			gcc -Wall -Wextra -Werror $@ && ./a.out
			echo -e "\n"
			sleep $SLEEP
		done
	else
		echo "$RED""no args $RST"
	fi
}

# all
function refresha()
{
	if [[ $# == 0 ]];
	then
		while true; do
			tput clear
			tput cup 0 0
			echo -e $BACK_CYAN" ----- START ----- "$RST"\n"
			rm -f *.gch
			gcc -Wall -Wextra -Werror *.c *.h && ./a.out
			echo -e "\n"
			sleep $SLEEP
		done
	else
		while true; do
			tput clear
			tput cup 0 0
			echo -e $BACK_CYAN" ----- START ----- "$RST"\n"
			rm -f *.gch
			gcc -Wall -Wextra -Werror *.c *.h && ./a.out $@
			echo -e "\n"
			sleep $SLEEP
		done
	fi
}

# all sub
function refresh_all()
{
	gcc -Wall -Wextra -Werror *.c */*.c
	while true; do
		tput clear
		tput cup 0 0
		echo -e $BACK_CYAN" ----- START ----- "$RST" $BACK_YELLOW $(date +"%H:%M:%S") $RST\n"
		rm -f *.gch && rm -f */*.gch
		if [[ -f "$(pwd)/a.out" ]]; then
			if [[ $# > 0 ]]
			then
				./a.out $@ && gcc -Wall -Wextra -Werror *.c */*.c
			else
				./a.out && gcc -Wall -Wextra -Werror *.c */*.c
			fi
		else
			gcc -Wall -Wextra -Werror *.c */*.c
		fi
		SECONDS=$SLEEP
		while [[ $SECONDS -ge 0 ]]; do
			tput cup 0 31; echo -e "$BACK_WHITE $SECONDS sec $RST"
			tput cup 0 31
			sleep 0.5
			let "SECONDS-=1"
		done
		rm -f *.gch && rm -f */*.gch
		echo -e "\n"
		sleep $SLEEP
	done
}

# norm refresh
function refreshn()
{
	# let "SLEEP+=2"
	SECONDS=$SLEEP
	while true; do
		nbr_lines=$(tput lines)
		nbr_lines=$(($nbr_lines-8))
		nbr_norm=$(normi | wc -l)

		tput clear
		tput cup 0 0

		echo -e "\t""$BACK_GREEN ----- ----- NORMINETTE ----- ----- $RST"


		norminette $1 | grep -vi OK | head -14

		echo ""
		nbr_error=$(norminette $1 | grep -i Error! | wc -l)
		nbr_ok=$(norminette $1 | grep -i OK! | wc -l)
		nbr_total=0
		let "nbr_total=$nbr_error+$nbr_ok"
		res=$(echo "scale=2; $nbr_ok / $nbr_total *100" | bc )

		echo -ne "$BOLD_RED""Error in $nbr_error files \t"$RST
		echo -ne "$BOLD_GREEN""OK in $nbr_ok files \t\t"$RST
		echo -ne "number of files: $BOLD_WHITE$nbr_total    \t"$RST
		echo -ne "perc: $BOLD_WHITE$res"
		echo " %"
		SECONDS=$SLEEP
		while [[ $SECONDS -ge 0 ]]; do
			tput cup 0 46; echo -e "$BACK_WHITE $SECONDS sec $RST"
			tput cup 0 45
			sleep 0.5
			let "SECONDS-=1"
		done
		# if [[ $# == 0 ]]
		# then
		# 	norm+ | head -$nbr_lines
		# else
		# 	norm+ $@ | head -$nbr_lines
		# fi
	done
}

function refreshn_test()
{
	# let "SLEEP+=2"
	SECONDS=$SLEEP
	while true; do
		nbr_lines=$(tput lines)
		nbr_lines=$(($nbr_lines-8))
		nbr_norm=$(normi | wc -l)

		tput clear
		tput cup 0 0

		echo -e "\t""$BACK_GREEN ----- ----- NORMINETTE ----- ----- $RST"

		norminette | grep -vi OK | head -14

		echo ""
		nbr_error=$(norminette | grep -i Error! | grep -vi  | wc -l)
		nbr_ok=$(norminette | grep -i OK! | grep -vi  | wc -l)
		nbr_total=0
		let "nbr_total=$nbr_error+$nbr_ok"
		res=$(echo "scale=2; $nbr_ok / $nbr_total *100" | bc )

		echo -ne "$BOLD_RED""Error in $nbr_error files \t"$RST
		echo -ne "$BOLD_GREEN""OK in $nbr_ok files \t\t"$RST
		echo -ne "number of files: $BOLD_WHITE$nbr_total    \t"$RST
		echo -ne "perc: $BOLD_WHITE$res"
		echo " %"
		SECONDS=$SLEEP
		while [[ $SECONDS -ge 0 ]]; do
			tput cup 0 46; echo -e "$BACK_WHITE $SECONDS sec $RST"
			tput cup 0 45
			sleep 0.5
			let "SECONDS-=1"
		done
		# if [[ $# == 0 ]]
		# then
		# 	norm+ | head -$nbr_lines
		# else
		# 	norm+ $@ | head -$nbr_lines
		# fi
	done
}

function clr()
{
	if [[ "${1/-f}" != $1 ]]; then
		rm -f *.gch
		rm -f a.out
		rm -rf */.vscode
		rm -rf .vscode
		clear
	else
		echo "are you sure to clear :\n_ file.gch\n_ a.out\n_ .vscode\n?\n"
		read -r answer
		if [[ $answer == "yes" || $answer == "y" ]]; then
			rm -f *.gch
			rm -f *.swp
			# rm -f */*.gch
			# rm -f */*.swp
			rm -f a.out
			rm -f $exe_name
			rm -rf .vscode
			clear
		else
			echo -e $NOTHING
		fi
	fi
}

function crt()
{
	if [[ $# == 1 ]]
	then
		if [[ ! -d "$1" ]]; then
			mkdir $1 && cd $1 && code .
		else
			echo "$1 already exist"
		fi
	else
		echo -e $W_ARGS
	fi
}
function crtf()
{
	if [[ $# == 1 ]]
	then
		if [[ ! -f "$1" ]]; then
			touch $1 && code $1
		else
			echo "$1 already exist"
		fi
	else
		echo -e $W_ARGS
	fi
}

# function
function is_in()
{
	if [[ $# == 2 ]]
	then
		big=$1
		needle=$2
		echo ${big/$needle}
		if [[ "${big/$needle}" == $big ]]
		then
			echo "nothing"
		else
			echo "something here"
		fi
	else
		echo -e $W_ARGS
	fi
}

function is_number()
{
	if ! [[ $1 =~ '^[0-9]+$' ]];
	then
		echo "error: Not a number"
		# >&2; exit 1
	fi
}

function print_arr()
{
	arr=$1
	for item in "${arr[@]}"
	do
		echo $item
	done
}

function nds()
{
	if [[ $# == 1 || $# == 2 ]]; then
		big=$1
		ext_js=".js"
		if [[ "${big/$ext_js}" == $big ]]
		then
			ext=".js"
			file=$1$ext
		else
			file=$1
		fi

		if [[ -f $file ]]; then
			echo -e "$BOLD_YELLOW$file$RST exist and it is launched with $BOLD_GREEN""node$RST"
			if [[ $2 == "-c" ]]; then
				echo -e "and $BOLD_CYAN""vscode$RST"
				code $file
			fi
			node $file
		else
			echo -e "\n$BOLD_YELLOW$file$RST does not exist, do you want to create it ? $BOLD_YELLOW(y/n)$RST\n"
			echo -e "$RED(!) Check the path before to answer the question (!)$RST"
			echo -e "$RED--->$RST $(pwd)$RST"
			read answer
			if [[ $answer == "y" || $answer == "yes" ]]; then
				touch $file
				echo -e "\t$BOLD_YELLOW$file$RST\tcreated"
				if [[ $2 == "-c" ]]; then
					echo -e "$BOLD_YELLOW$file$RST is launch with $BOLD_BLUE""node$RST"
					code $file
				fi
			else
				echo -e "$BOLD_YELLOW""nothing happened üëí$RST"
			fi
		fi
	else
		echo -e $W_ARGS
	fi
}

# function ndst()
# {
# 	if [[ $# == 1 || $# == 2 ]]; then
# 		big=$1
# 		ext_js=".js"
# 		ext_ts=".ts"
# 		if [[ "${big/$ext_ts}" == $big ]]
# 		then
# 			ext=".ts"
# 			ts_file=$1$ext
# 		elif [[ "${big/$ext_js}" == $big ]]
# 		then
# 			ext=".js"
# 			js_file=$1$ext
# 		else
# 			file=$1
# 		fi

# 		if [[ -f $js_file ]]; then
# 			echo -e "$BOLD_YELLOW$js_file$RST exist and it is launched with $BOLD_GREEN""node$RST"
# 			if [[ $2 == "-c" ]]; then
# 				echo -e "and $BOLD_CYAN""vscode$RST"
# 				code $js_file
# 			fi
# 			if [[ "${big/$ext_ts}" == $big ]]
# 			then
# 				node $js_file
# 		else
# 			echo -e "\n$BOLD_YELLOW$file$RST does not exist, do you want to create it ? $BOLD_YELLOW(0,1,2) (no, js, ts)$RST\n"
# 			echo -e "$RED(!) Check the path before to answer the question (!)$RST"
# 			echo -e "$RED--->$RST $(pwd)$RST"
# 			read answer
# 			if [[ $answer == "1" || $answer == "2" ]]; then
# 				touch $file
# 				echo -e "\t$BOLD_YELLOW$js_file$RST\tcreated"
# 				if [[ $2 == "-c" ]]; then
# 					echo -e "$BOLD_YELLOW$js_file$RST is launch with $BOLD_BLUE""node$RST"
# 					code $js_file
# 				fi
# 			else
# 				echo -e "$BOLD_YELLOW""nothing happened üëí$RST"
# 			fi
# 		fi
# 	else
# 		echo -e $W_ARGS
# 	fi
# }

function rmv()
{
	if [[ $# == 1 ]]; then
		if echo $1 | grep -q '*'; then
			echo
		else
			if [[ -f $1 ]]
			then
				echo
				echo -e "$(file $1 | awk -F ':' '{print "\033[32;1m"$1 "\033[0m:" $2}')\t$BOLD_WHITE""size:$RST $BOLD_GREEN$(du -sh $1 | awk '{print $1}')$RST"
				echo
				echo -e "	$(stat $1 | tail -n3 | head -1 | awk '{print $1}' | awk -F ':' '{print "\033[37;1m"$1"\033[0m" $2}')\t$(stat $1 | tail -n1 | awk '{print "\033[32m"$2}') $(stat $1 | tail -n1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo -e "	$(stat $1 | tail -n1 | awk '{print $1}' | awk -F ':' '{print "\033[37;1m"$1"\033[0m" $2}')\t$(stat $1 | tail -n1 | awk '{print "\033[32m"$2}') $(stat $1 | tail -n1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo
				echo -e "Do you really want to remove the file $BOLD_GREEN $1 $RST ? (y/n) ‚îÄ‚îê"
				echo -ne "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
				str=$1
				n=0
				while read -n1 character; do
					n=$((n+1));
					echo -n "‚îÄ"
				done < <(echo -n "$str")
				echo -e "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
				echo -e "‚îî‚îÄ path: $GREEN$(pwd)/$BOLD_GREEN$1$RST"
				sleep 3
				read answer
				if [[ $answer == "y" || $answer == "yes" ]]
				then
					echo -e $RED"/usr/bin/rm -f $1"$RST
					/usr/bin/rm -f "$1"
				else
					echo -e $NOTHING
				fi
				echo
			elif [[ -d $1 ]]
			then
				echo
				echo -e "$(file $1 | awk -F ':' '{print "\033[36;1m"$1 "\033[0m:" $2}')\t$BOLD_WHITE""size:$RST $BOLD_CYAN$(du -sh $1 | awk '{print $1}')$RST"
				echo
				echo -e "	$(stat $1 | tail -n3 | head -1 | awk '{print $1}' | awk -F ':' '{print "\033[37;1m"$1"\033[0m" $2}')\t$(stat $1 | tail -n1 | awk '{print "\033[36m"$2}') $(stat $1 | tail -n1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo -e "	$(stat $1 | tail -n1 | awk '{print $1}' | awk -F ':' '{print "\033[37;1m"$1"\033[0m" $2}')\t$(stat $1 | tail -n1 | awk '{print "\033[36m"$2}') $(stat $1 | tail -n1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo
				echo -e "Do you really want to remove the folder $BOLD_CYAN $1 $RST ? (y/n) ‚îÄ‚îê"
				echo -ne "‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
				str=$1
				n=0
				while read -n1 character; do
					n=$((n+1));
					echo -ne "‚îÄ"
				done < <(echo -n "$str")
				echo -e "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò"
				echo -e "‚îî‚îÄ path: $CYAN$(pwd)/$BOLD_CYAN$1$RST"
				sleep 3
				read answer
				if [[ $answer == "y" || $answer == "yes" ]]
				then
					echo -e $RED"/usr/bin/rm -rf $1"$RST
					/usr/bin/rm -rf "$1"
				else
					echo -e $NOTHING
				fi
				echo
			else
				# echo "$1 is not a file or a directory, are you sure to delete it ?"
				echo -e "   $BOLD_WHITE~~$RST $1 is not a file or a directory $BOLD_WHITE~~$RST"
				echo -e "\t$BOLD_WHITE~~$RST are you sure to delete it ? $BOLD_WHITE~~$RST"
				sleep 3
				read answer
				if [[ $answer == 'y' || $answer == 'yes' ]]; then
					echo "rm -rf $1"
					/usr/bin/rm -rf $1
				else
					echo -e $NOTHING
				fi
			fi
		fi
	else
		echo -e $W_ARGS
	fi
}

# function too_much_time_time_to_reboot()
# {

# }

function before()
{
	cat save.h > ft_philo.h
}

function t46()
{
	FILE=$PWD"/.folder_ignore"
	if test -f "$FILE"; then
		echo ".folder_ignore exists."
		echo
	else
		echo "Which folder do you want to exclude from hcreate ? (end)"
		answer=""
		while [[ $answer != "end" ]]
		do
			read -a answer
			if [[ $answer != "end" ]]
			then
				echo $answer >> $FILE
			fi
		done
		touch $FILE
	fi
	readarray -t abc < $FILE
	for val in "${abc[@]}";
	do
		echo $val
		echo "---"
	done
	echo "------"
}

function hcreate()
{
	FILE=$PWD"/.folder_ignore"
	if test -f "$FILE"; then
		echo "$FILE exists."
	else
		echo "Which folder do you want to exclude from hcreate ? (end)"
		answer=""
		while [[ $answer != "end" ]]
		do
			read -a answer
			if [[ $answer != "end" ]]
			then
				echo $answer >> $FILE
			fi
		done
		touch $FILE
	fi
	return ;
	if [[ $# == 1 ]]
	then
		folder=$1
	else
		folder=$(basename $PWD)
	fi
	header_file="ft_$folder"".h"
	header_name="FT_$(echo $folder | tr a-z A-Z)""_H"
	date_ymd=$(date +%Y/%m/%d)
	date_hms=$(date +%H:%M:%S)

	save_created="nothing"
	if [ -f $header_file ]
	then
		if [[ $(cat $header_file | wc -m) -gt 0 ]]
		then
			save_created=$(sed -n '/Created/{p;};x' $header_file)
		fi
	fi
	save_struct="nothing"
	if [ -f $header_file ]
	then
		result_struct=$(cat $header_file | grep typedef | wc -l)
		if [[ $result_struct -gt 0 ]]
		then
			start_struct=$(cat $header_file | grep -on --color=never "// ------------------------------ struct ------------------------------------ //" | awk -F ':' '{print $1}')
			end_struct=$(cat $header_file | grep -on --color=never "// ---------------------------- end struct ---------------------------------- //" | awk -F ':' '{print $1}')
			IFS=$'\n'
			save_struct=($(sed -n "$start_struct,$end_struct p" $header_file))
		fi

		start_include=$(cat $header_file | grep -on --color=never "// ------------------------------ include ----------------------------------- //" | awk -F ':' '{print $1}')
		end_include=$(cat $header_file | grep -on --color=never "// ---------------------------- end include --------------------------------- //" | awk -F ':' '{print $1}')
		IFS=$'\n'
		save_include=($(sed -n "$start_include,$end_include p" $header_file))

		start_define=$(cat $header_file | grep -on --color=never "// ------------------------------ define ------------------------------------ //" | awk -F ':' '{print $1}')
		end_define=$(cat $header_file | grep -on --color=never "// ---------------------------- end define ---------------------------------- //" | awk -F ':' '{print $1}')
		IFS=$'\n'
		save_define=($(sed -n "$start_define,$end_define p" $header_file))

	else
		echo "nothing"
	fi


	##### ERASE #####
	> $header_file;

	##### str_name #####
	str_name="/*   $header_file"
	nbr_char=${#str_name}
	nbr_char=$(($nbr_char + 24))
	while [[ $nbr_char -lt 80 ]]
	do
		str_name="$str_name "
		nbr_char=$(($nbr_char + 1))
	done
	str_name="$str_name:+:      :+:    :+:   */"

	##### by #####
	str_by="/*   By: $(whoami) <$(whoami)@student.42.fr>"
	nbr_char=${#str_by}
	nbr_char=$(($nbr_char + 28))
	while [[ $nbr_char -lt 80 ]]
	do
		str_by="$str_by "
		nbr_char=$(($nbr_char + 1))
	done
	str_by="$str_by+#+  +:+       +#+        */"

	##### created #####
	str_created="/*   Created: $date_ymd $date_hms by $(whoami)"
	nbr_char=${#str_created}
	nbr_char=$(($nbr_char + 25))
	while [[ $nbr_char -lt 80 ]]
	do
		str_created="$str_created "
		nbr_char=$(($nbr_char + 1))
	done
	str_created="$str_created#+#    #+#             */"

	##### updated #####
	str_updated="/*   Updated: $date_ymd $date_hms by $(whoami)"
	nbr_char=${#str_updated}
	nbr_char=$(($nbr_char + 26))
	while [[ $nbr_char -lt 80 ]]
	do
		str_updated="$str_updated "
		nbr_char=$(($nbr_char + 1))
	done
	str_updated="$str_updated###   ########.fr       */"

	echo "/* ************************************************************************** */" >> $header_file
	echo "/*                                                                            */" >> $header_file
	echo "/*                                                        :::      ::::::::   */" >> $header_file
	echo "$str_name" >> $header_file
	echo "/*                                                    +:+ +:+         +:+     */" >> $header_file
	echo "$str_by" >> $header_file
	echo "/*                                                +#+#+#+#+#+   +#+           */" >> $header_file
	if [[ $save_created == "nothing" ]]
	then
		echo "$str_created" >> $header_file
	else
		echo "$save_created" >> $header_file
	fi
	echo "$str_updated" >> $header_file
	echo "/*                                                                            */" >> $header_file
	echo "/* ************************************************************************** */" >> $header_file


	echo -e "\n#ifndef $header_name" >> $header_file
	echo -e "# define $header_name\n" >> $header_file

	echo "# include <dirent.h>" >> $header_file
	echo "# include <errno.h>" >> $header_file
	echo "# include <fcntl.h>" >> $header_file
	echo "# include <limits.h>" >> $header_file
	echo "# include <pthread.h>" >> $header_file

	echo "# include <sys/types.h>" >> $header_file
	echo "# include <sys/time.h>" >> $header_file
	echo "# include <sys/resource.h>" >> $header_file
	echo "# include <sys/wait.h>" >> $header_file
	echo "# include <sys/stat.h>" >> $header_file
	echo "# include <sys/ioctl.h>" >> $header_file

	echo "# include <signal.h>" >> $header_file
	echo "# include <stdarg.h>" >> $header_file
	echo "# include <stddef.h>" >> $header_file
	echo "# include <stdarg.h>" >> $header_file
	echo "# include <stdio.h>" >> $header_file
	echo "# include <stdlib.h>" >> $header_file
	echo "# include <string.h>" >> $header_file
	echo "# include <termios.h>" >> $header_file
	echo "# include <unistd.h>" >> $header_file

	echo "# include <readline/readline.h>" >> $header_file
	echo "# include <readline/history.h>" >> $header_file

	echo "" >> $header_file

	##### save_include #####
	if [[ $save_include != "nothing" ]]
	then
		for val in "${save_include[@]}";
		do
			if [[ "$val" == *"typedef"* ]]
			then
				echo -e "\n$val" >> $header_file
			else
				echo "$val" >> $header_file
			fi
		done
	fi
	echo "" >> $header_file
	##### end_place_include #####


	##### save_define #####
	if [[ $save_define != "nothing" ]]
	then
		for val in "${save_define[@]}";
		do
			echo "$val" >> $header_file
		done
	fi
	echo "" >> $header_file
	##### end_place_define #####

	struct_type=()
	##### save struct #####
	if [[ $save_struct != "nothing" ]]
	then
		for val in "${save_struct[@]}";
		do
			if [[ "$val" == *"typedef"* || "$val" == *"enum e_"* ]]
			then
				echo -e "\n$val" >> $header_file
			else
				if [[ $val == *"}"* ]]
				then
					res=`echo $val | tr -d '\t' | tr -d '}' | tr -d ';'`
					if [[ "$res" =~ [A-Za-z] ]]; then
						# echo $res
						struct_type+=( "$res" )
					fi
				fi
				echo "$val" >> $header_file
			fi
		done
	fi
	# if [[ ${#struct_type[@]} -eq 0 ]]
	# then
	# 	printf "struct_type array is empty\n"
	# fi
	echo "" >> $header_file
	##### end_place_struct #####


	##### get_function #####
	IFS=$'\n'
	functions=($(find . -type f -name '*.[ch]' -exec ctags -x --c-kinds=f {} ';' | awk '{
		if ($4 ~ "libft")
		{
			next;
		}
		else
		{
			print $4;
			$1=$2=$3=$4="";
			print $0;
		}
	}'))

	for val in "${functions[@]}";
	do
		if [[ $val != *"main("* ]]
		then
			if [[ $(cat $header_file | grep -on "$val" --color=never | wc -l) -eq 0 ]]
			then
				echo $val >> $header_file
			fi
		fi
	done
	###	add this snippet between if and else if you want to exclude a folder (ex:minilibx)
	#
	#	else if ($4 ~ "minilibx")
	#	{
	#		next;
	#	}
	if [[ $(cat $header_file | grep "main(" | wc -l) -eq 1 ]]
	then
		lnbr_main=$(cat $header_file | grep "main(" -n --color=never | awk -F ':' '{print $1}')
		lnbr_main=$(($lnbr_main-1))
		# sed -i "$lnbr_main d" $header_file
		# sed -i "$lnbr_main d" $header_file
	elif [[ $(cat $header_file | grep "main(" | wc -l) -gt 1 ]]
	then
		echo "error detected (script continue)"
		# echo "two function main(... detected"
	fi


	#---- a faire : find max length of all type present -> define number of tab for each type (basics + struct) for norm ----#


	# norm with type in header
	sed -i '/static /d' $header_file
	sed -i '/main(/d' $header_file
	sed -i 's/\.\//\/\//' $header_file
	sed -i ':a;N;$!ba;s/)\n/);\n/g' $header_file
	sed -i ':a;N;$!ba;s/)$/);/g' $header_file
	sed -i ':a;N;$!ba;s/\n\ \ \ \ /\n/g' $header_file
	sed -i ':a;N;$!ba;s/\nvoid\ /\nvoid\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nint\ /\nint\t\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nchar\ /\nchar\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nlong\ int\ /\nlong\ int\t\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nunsigned\ int\ /\nunsigned\ int\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nunsigned\ char\ /\nunsigned\ char\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nlong\ long\ int\ /\nlong\ long\ int\t/g' $header_file

	for val in "${struct_type[@]}";
	do
		start="\n$val\ "
		end="${start}"
		res="sed -i '"
		res=$res':a;N;$!ba;s/'
		res=$res$start
		res=$res"/"
		res=$res"\n$val\t"
		res=$res"/g' $header_file"
		echo $res >> "$PWD/sh.sh"
		echo "" >> "$PWD/sh.sh"
	done
	source "$PWD/sh.sh"
	/usr/bin/rm "$PWD/sh.sh"


	echo "" >> $header_file
	echo -n "#endif" >> $header_file
}


function vlg()
{
	echo -e $BOLD_WHITE"\tvalgrind"$RST
	echo "--show-leak-kinds=all"
	echo "--leak-check=<no|summary|yes|full>"
	echo "--track-origins=<yes|no>"
	echo "--track-fds=<yes|no|all>"
}

function kill_search()
{
	if [[ $# == 1 ]]
	then
		if top -bn1 | grep --color=never -iq $1
		then
			pid=$(top -bn1 -o +%MEM | grep --color=never -i $1 | head -1 | awk '{print $1}')
			name=$(top -bn1 -o +%MEM | grep --color=never -i $1 | head -1 | awk '{print $12}')
			echo -e "do you want to kill $RED$name$RST    with pid: $RED$pid$RST ? (y/n)"
			read answer
			if [[ $answer == "y" ]]
			then
				kill -9 $pid
				echo -e $BOLD_RED"$name$RED was killed"$RST
			else
				echo -e $NOTHING
			fi
		else
			echo -e "nothing found"
		fi
	else
		echo -e $W_ARGS
	fi
}

function high_mem()
{
	line="$(top -bn1 -o +%MEM | head -n 8 | tail -1)"
	pid="$(top -bn1 -o +%MEM | head -n 8 | tail -1 | awk '{print $1}')"
	task_name="$(top -bn1 -o +%MEM | head -n 8 | tail -1 | awk '{print $12}')"
	echo -e $line
	if [[ $task_name != "plasmashell" && $task_name != "kwin_x11" ]]; then
		echo -e "$BOLD_RED "$task_name" was killed $RST"
		kill -9 $pid
	else
		echo -e "$BOLD_YELLOW""nothing happened üëí$RST"
	fi
}

function high_cpu()
{
	line="$(top -bn1 -o +%CPU | head -n 8 | tail -1)"
	pid="$(top -bn1 -o +%CPU | head -n 8 | tail -1 | awk '{print $1}')"
	task_name="$(top -bn1 -o +%CPU | head -n 8 | tail -1 | awk '{print $12}')"
	echo -e $line
	if [[ $task_name != "plasmashell" && $task_name != "kwin_x11" ]]; then
		echo -e "$BOLD_RED "$task_name" was killed $RST"
		kill -9 $pid
	else
		echo -e "$BOLD_YELLOW""nothing happened üëí$RST"
	fi
}

function vmem()
{
	if [ -z "$1" ]; then
		# echo "5 most task memory used"
		top -bn1 -o %MEM | head -n 12 | tail -7
	else
		# echo "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		top -bn1 -o %MEM | head -n $hd | tail -$tl
		# echo "hd "$hd
		# echo "start "$start
	fi
}
function vcpu()
{
	if [ -z "$1" ]; then
		# echo "5 most task memory used"
		top -bn1 -o %CPU | head -n 12 | tail -7
	else
		# echo "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		top -bn1 -o %CPU | head -n $hd | tail -$tl
		# echo "hd "$hd
		# echo "start "$start
	fi
}
function vstat()
{
	if [ -z "$1" ]; then
		# "5 most task memory used"
		echo -e "$BLUE\e[4m CPU $BLUE"
		top -bn1 -o %CPU | head -n 12 | tail -7
		echo -e "$GREEN\e[4m MEM $GREEN"
		top -bn1 -o %MEM | head -n 12 | tail -7
	else
		# "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		echo -e "$BLUE\e[4m CPU $BLUE"
		top -bn1 -o %CPU | head -n $hd | tail -$tl
		echo -e "$GREEN\e[4m MEM $GREEN"
		top -bn1 -o %MEM | head -n $hd | tail -$tl
	fi
}

function scan()
{
	compile=0
	if [ -f "$(pwd)/Makefile" ]
	then
		compile=1
		scan-build make re
	else
		compile=1
		c_at_root=$(ls *.c | wc -l)
		c_in_sub=$(ls */*.c | wc -l)
		h_at_root=$(ls *.h | wc -l)
		h_in_sub=$(ls */*.h | wc -l)
		if [[ $c_at_root -gt 0 ]]
		then
			if [[ $h_at_root -gt 0 ]]
			then
				if [[ $c_in_sub -gt 0 ]]
				then
					if [[ $h_in_sub -gt 0 ]]
					then
						scan-build gcc -Wall -Wextra -Werror *.c */*.c *.h */*.h
					else
						scan-build gcc -Wall -Wextra -Werror *.c */*.c *.h
					fi
				else
					scan-build gcc -Wall -Wextra -Werror *.c *.h
				fi
			elif [[ $c_in_sub -gt 0 ]]
			then
				if [[ $h_in_sub -gt 0 ]]
				then
					scan-build gcc -Wall -Wextra -Werror *.c */*.c */*.h
				else
					scan-build gcc -Wall -Wextra -Werror *.c */*.c
				fi
			else
				scan-build gcc -Wall -Wextra -Werror *.c
			fi
		else
			echo $RED"nothing to compile"$RST
		fi
	fi
	if [[ $compile -eq 1 ]]
	then
		scan-view "/tmp/$(ls -lt /tmp/ | grep "scan-build" --color=never | head -1 | awk '{print $9}')"
	fi
}

function print_title()
{
	escp="\e["
	wrt=";3"
	echo -e $escp"2"$wrt$2"m>"$escp"0"$wrt$2"m>"$escp"1"$wrt$2"m>" $1 $escp"1"$wrt$2"m<"$escp"0"$wrt$2"m<"$escp"2"$wrt$2"m<$RST"
	# echo -e "\e[2;3$2m"">""\e[0;3$2m"">""\e[1;3$2m"">" $1 "\e[1;3$2m""<""\e[0;3$2m""<""\e[2;3$2m""<$RST"

}

function search()
{
	if [ -z "$  1" ]; then
		echo "first arg missing"
	else
		grep -riIn -B 4 $1
		if [[ $(grep -riIon $1 | wc -l) == 1 ]]; then
			a="$(grep -riIon $1 | sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | awk -F ":" '{print $1":"$2}')"
			code -g $a
		else
			echo -e $BACK_RED" $(grep -riIon $1 | wc -l) results, expected : 1 "$RST
			echo -e "\nsearch again for 1 result"
			echo -n "$> "
			read answer
			echo ""
			search $answer
			# b="$(tr -d \\033 $a :$1)"
			# echo -e $b
		fi
	fi
}

function split()
{
	if [[ $# == 0 ]]; then
		echo "Missing args, the first must be the string and the second will be the delimiter"
	elif [[ $# == 1 ]]; then
		text=$1
		IFS=' '
		read -a strarr <<< "$text"
		echo -e "length: ${#strarr[*]} \n"
		for val in "${strarr[@]}";
		do
			printf "$val\n"
		done
	elif [[ $# == 2 ]]; then
		text=$1
		IFS=$2
		read -a strarr <<< "$text"
		echo -e "length: ${#strarr[*]} \n"
		for val in "${strarr[@]}";
		do
			printf "$val\n"
		done
	fi
}

function size()
{
	# res=$(printf "%b" "$(sudo du -shc $(pwd)/* | sort -n)")
	# echo $res
	echo -e "size in $RED K $RST"
	sudo du -shc $(pwd)/* | sort -n | awk '{ if ($1 ~ /K/) {print $1,$2}}'
	echo
	echo -e "size in $RED M $RST"
	sudo du -shc $(pwd)/* | sort -n | awk '{ if ($1 ~ /M/) {print $1,$2}}'
	echo
	echo -e "size in $RED G $RST"
	sudo du -shc $(pwd)/* | sort -n | awk '{ if ($1 ~ /G/) {print $1,$2}}'
	echo
}

function onorm_file()
{
	IFS=$'\n'
	toggle=1
	str=''
	array=( $(norminette $1 | grep Error! -A 1 --color=never) )
	for val in "${array[@]}"
	do
		if [[ $val != "--" ]]
		then
			echo $val
			if [[ $toggle == 1 ]]
			then
				str=$(echo -n $val | awk '{print $1}')
				# | tr 'Error!' ' '
				toggle=0
			else
				str+=$(echo $val | awk '{print $4}' | tr ',' ' ')
				toggle=1
				str=( $(echo $str | tr -d ' ') )
				code -g $str
				echo
			fi
		fi
	done
}

function norm_file()
{
	IFS=$'\n'
	toggle=2
	str=''
	glb=0
	array=( $(norminette $1 | grep Error! -A 2 --color=never) )
	for val in "${array[@]}"
	do
		if [[ $val != "--" ]]
		then
			if [[ $toggle == 2 ]]
			then
				echo $val
				str=$(echo -n $val | awk '{print $1}')
				# | tr 'Error!' ' '
				toggle=1
			elif [[ $toggle == 1 ]]
			then
				if echo $val | grep -q GLOBAL_VAR_DETECTED;
				then
					glb=1
				else
					echo $val
					str+=$(echo $val | awk '{print $4}' | tr ',' ' ')
					str=( $(echo $str | tr -d ' ') )
					code -g $str
					echo
				fi
				toggle=0

			else
				if [[ $glb == 1 ]]
				then
					echo $val
					str+=$(echo $val | awk '{print $4}' | tr ',' ' ')
					toggle=0
					str=( $(echo $str | tr -d ' ') )
					code -g $str
					echo
					glb=0
				fi
				toggle=2
			fi
		fi
	done
}

function pyramid()
{
	# echo -e "requirement:"
	# echo -e " download egypt, extract and cd into the egypt folder"
	# echo -e " perl Makefile.PL"
	# echo -e " sudo make install"
	# echo -e " install graphviz"
	# echo -e ""
	# echo -e "cmd:"
	# echo -e "make CFLAGS=-fdump-rtl-expand"
	# echo -e "egypt $(find . -name '*.expand' -print) | dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o ./call"
	# make CFLAGS=
	echo "in makefile: -fdump-rtl-expand"
	make re CFLAGS=-fdump-rtl-expand
	egypt $(find . -name '*.expand' -print) | dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o ./call
}

function where_cfg()
{
	SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
	echo $SCRIPT_DIR
}

function ffd()
{
	file="$(basename $PWD).c"
	touch $file && code $file
}

function date_man()
{
	man date | head -144 | tail -n 92
}

function kill_task()
{
	if [[ $# == 1 ]]
	then
		IFS=$'\n'
		res=($(top -bn1 | grep -i $1))
		for val in ${res[@]}
		do
			echo $val
		done
	else
		echo -e $W_ARGS
	fi
}

function end()
{
	date;
	# git status;
	sleep 0.5;
	pkill --oldest chrome;
	sleep 0.5;
	pkill --oldest chrome;
	sleep 0.5;
	pkill --oldest Discord;
	sleep 0.5;
	pkill --newest code;
	sleep 0.5;
	pkill --oldest code;
	sleep 0.5;
	pkill --oldest bash;
	sleep 0.5;
	pkill --oldest bash;
	sleep 0.5;
	pkill --oldest bash;
	ft_lock;
}

function end_work()
{
	if [[ $# == 0 ]]; then
		echo "missing arg(s)";
	else
		message="$1"
		date
		git status
		echo
		echo -e $BOLD_BLACK$BACK_GREEN" Poush $RESET$BOLD_WHITE $1"$RESET
		echo
		sleep 2
		if git add . 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong : git add ."$RST
			return 0;
		fi
		echo -e $CYAN"stop"$RST
		git commit -m $message
		if git push 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong with $BOLD_RED git push"$RST
			return 0;
		fi
		echo
		echo -e $BOLD_BLACK$BACK_GREEN" End poush $RESET$BOLD_WHITE $1"$RESET
		echo
		git status
		sleep 0.5
		pkill --oldest chrome
		sleep 0.5
		pkill --oldest chrome
		sleep 0.5
		pkill --oldest Discord
		sleep 0.5
		pkill --oldest bash
		sleep 0.5
		pkill --oldest bash
		sleep 0.5
		pkill --oldest bash
		sleep 0.5
		pkill --oldest obs
		sleep 0.5
		pkill --oldest obsidian
		sleep 0.5
		pkill --newest code
		sleep 0.5
		pkill --oldest code
		ft_lock
	fi
}

function act()
{
	complete -d /mnt/nfs/homes/$USER/42/cursus/ && cd ~/42/cursus/$1
}

function work()
{
	if [ -z $1 ]; then
		echo "first arg missing";
	else
		cd;
		cd 42;
		git pull;
		cd ~/42/cursus/$1 && code . && sleep 3 && google-chrome;
	fi
}

function brgt()
{
	LEVEL=$1;
	if [[ $LEVEL -gt 100 ]]; then
		echo -e $SYNTAX;
		exit 1;
	fi;
	if [[ $LEVEL -lt 0 ]]; then
		echo -e $SYNTAX;
		exit 1;
	fi;
	brightness_level="$(( LEVEL / 100 )).$(( LEVEL % 100 ))";
	screenname=$(xrandr | grep " connected" | cut -f1 -d" ");
	echo "$(xrandr --output $screenname --brightness $brightness_level)"
}

function low()
{
	if [[ $1 == "clr" ]]; then
		xrandr --output HDMI-2 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-1 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-2 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-3 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-4 --gamma 1:1:1 --brightness 0.5;
	else
		xrandr --output HDMI-2 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-1 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-2 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-3 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-4 --gamma 1:0.8:0.6 --brightness 0.5;
	fi
}

function mid()
{
	if [[ $1 == "clr" ]]; then
		xrandr --output HDMI-2 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-1 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-2 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-3 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-4 --gamma 1:1:1 --brightness 0.7;
	else
		xrandr --output HDMI-2 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-1 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-2 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-3 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-4 --gamma 1:0.8:0.6 --brightness 0.7;
	fi
}

function high()
{
	if [[ $1 == "clr" ]]; then
		xrandr --output HDMI-2 --gamma 1:1:1 --brightness 1 || xrandr --output DP-1 --gamma 1:1:1 --brightness 1 || xrandr --output DP-2 --gamma 1:1:1 --brightness 1 || xrandr --output DP-3 --gamma 1:1:1 --brightness 1 || xrandr --output DP-4 --gamma 1:1:1 --brightness 0.9;
	else
		xrandr --output HDMI-2 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-1 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-2 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-3 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-4 --gamma 1:0.8:0.6 --brightness 0.9;
	fi
}

function commit()
{
	if [[ $# == 0 ]]; then
		echo "missing arg(s)";
	else
		message="$1";
		date;
		save=$(pwd)
		git status;
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" Commit $RESET$BOLD_WHITE $1"$RESET;
		echo;
		sleep 2;
		if git add . 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong : git add ."$RST
			return 0;
		fi
		echo -e $CYAN"stop"$RST
		git commit -m $message
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" End Commit $RESET$BOLD_WHITE $1"$RESET;
		echo;
		git status;
		cd $save
	fi
}

function endlate()
{
	if [[ $# == 0 ]]; then
		echo "missing arg(s)";
	else
		message="$1";
		date;
		git status;
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" Poush $RESET$BOLD_WHITE $1"$RESET;
		echo;
		sleep 1.5;
		if git add . 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong : git add ."$RST
			git add .
			return 0;
		fi
		git commit -m $message
		if git push 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong with $BOLD_RED git push"$RST
			git push
			return 0;
		fi
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" End poush $RESET$BOLD_WHITE $1"$RESET;
		echo;
		git status;
		sleep 0.25;
		pkill --oldest chrome;
		sleep 0.25;
		pkill --oldest chrome;
		sleep 0.25;
		pkill --oldest Discord;
		sleep 0.25;
		pkill --oldest bash;
		sleep 0.25;
		pkill --oldest bash;
		sleep 0.25;
		pkill --oldest bash;
		sleep 0.25;
		pkill --oldest gnome-shell;
		sleep 0.25;
		pkill --oldest code;
	fi
}

function select_option() {

	# little helpers for terminal print control and key input
	ESC=$( printf "\033")
	cursor_blink_on()  { printf "$ESC[?25h"; }
	cursor_blink_off() { printf "$ESC[?25l"; }
	cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
	print_option()     { printf "   $1 "; }
	print_selected()   { printf "  $ESC[7m $1 $ESC[27m"; }
	get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
	key_input()        { read -s -n3 key 2>/dev/null >&2
						if [[ $key = $ESC[A ]]; then echo up;    fi
						if [[ $key = $ESC[B ]]; then echo down;  fi
						if [[ $key = ""     ]]; then echo enter; fi; }

	# initially print empty new lines (scroll down if at bottom of screen)
	for opt; do printf "\n"; done

	# determine current screen position for overwriting the options
	local lastrow=`get_cursor_row`
	local startrow=$(($lastrow - $#))

	# ensure cursor and input echoing back on upon a ctrl+c during read -s
	trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
	cursor_blink_off

	local selected=0
	while true; do
		# print options by overwriting the last lines
		local idx=0
		for opt; do
			cursor_to $(($startrow + $idx))
			if [ $idx -eq $selected ]; then
				print_selected "$opt"
			else
				print_option "$opt"
			fi
			((idx++))
		done

		# user key control
		case `key_input` in
			enter) break;;
			up)    ((selected--));
				if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
			down)  ((selected++));
				if [ $selected -ge $# ]; then selected=0; fi;;
		esac
	done

	# cursor position back to normal
	cursor_to $lastrow
	printf "\n"
	cursor_blink_on

	return $selected
}

function msearch()
{
	if [[ $# == 1 ]]
	then
		IFS='\n'
		res=$(grep -rion $1 --exclude-dir=".git" --color=never --binary-files=without-match)
		res=($res)

		echo ${#res[@]}
		if [[ $(echo ${res[@]} | wc -l) -eq 1 ]]
		then
			echo -e "do you want to open this file $GREEN$(echo $res | awk -F ':' '{print $1}')$RST at line $GREEN$(echo $res | awk -F ':' '{print $2}')$RST ? (y/n)"
			read answer
			if [[ $answer == "y" ]]
			then
				code -g "$(echo $res | awk -F ':' '{print $1":"$2}')"
			else
				echo $NOTHING
			fi
		else
			# echo "multiple"
			echo "Select file and line:"
			echo
			select_option "${res[@]}"
			choice=$?

			echo "Choosen index = $choice"
			echo "        value = ${options[$choice]}"
		fi

		# source ~/.bashrc
		# sleep 1.5
		# clear
		# msearch parsi
	else
		echo -e $W_ARGS
	fi
}

