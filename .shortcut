#!/bin/sh

##### Automatic variable #####
#		 !:0 = the name of command executed.
#		 !:1 = the first parameter of the previous command
#		 !:4 = the fourth parameter of the previous command
#		 !:* = all of the parameters of the previous command
#		 !^ = the first parameter of the previous command (same as !:1)
#		 !$ = the final parameter of the previous command
#		 !:-3 = all parameters in range 0-3 (inclusive)
#		 !:2-5 = all parameters in range 2-5 (inclusive)
#		 !! = the previous command line

##### COLORS #####

export DEBUGINFOD_URLS="https://debuginfod.archlinux.org/"
# lite
export BLACK="\033[0;30m"
export RED="\033[0;31m"
export GREEN="\033[0;32m"
export YELLOW="\033[0;33m"
export BLUE="\033[0;34m"
export PURPLE="\033[0;35m"
export CYAN="\033[0;36m"
export WHITE="\033[0;37m"

# bold color
export BOLD_BLACK="\033[1;30m"
export BOLD_RED="\033[1;31m"
export BOLD_GREEN="\033[1;32m"
export BOLD_YELLOW="\033[1;33m"
export BOLD_BLUE="\033[1;34m"
export BOLD_PURPLE="\033[1;35m"
export BOLD_CYAN="\033[1;36m"
export BOLD_WHITE="\033[1;37m"

# background
export BACK_BLACK="\033[0;40m"
export BACK_RED="\033[0;41;30m"
export BACK_GREEN="\033[0;42;30m"
export BACK_YELLOW="\033[0;43;30m"
export BACK_BLUE="\033[0;44;30m"
export BACK_PURPLE="\033[0;45;30m"
export BACK_CYAN="\033[0;46;30m"
export BACK_WHITE="\033[0;47;30m"

# bold & background
export BOLD_BACK_BLACK="\033[1;40m"
export BOLD_BACK_RED="\033[1;41;30m"
export BOLD_BACK_GREEN="\033[1;42;30m"
export BOLD_BACK_YELLOW="\033[1;43;30m"
export BOLD_BACK_BLUE="\033[1;44;30m"
export BOLD_BACK_PURPLE="\033[1;45;37m"
export BOLD_BACK_CYAN="\033[1;46;30m"
export BOLD_BACK_WHITE="\033[1;47;30m"

# underline color
export UNDERLINE_BLACK="\033[4;30m"
export UNDERLINE_RED="\033[4;31m"
export UNDERLINE_GREEN="\033[4;32m"
export UNDERLINE_YELLOW="\033[4;33m"
export UNDERLINE_BLUE="\033[4;34m"
export UNDERLINE_PURPLE="\033[4;35m"
export UNDERLINE_CYAN="\033[4;36m"
export UNDERLINE_WHITE="\033[4;37m"

export RST="\033[0m"

export NOTHING="$BOLD_YELLOW""nothing happened 👒$RST"
export W_ARGS="$RED""wrong numbers of args$RST"

export DEBUGINFOD_URLS="https://debuginfod.archlinux.org/"
# bind -s 'set completion-ignore-case on'

alias norm='norminette | grep -vi ok'
alias gcw='gcc -Wall -Wextra -Werror -g'

alias gcl='git clone'

alias ..='cd ..'
alias c='clear'
alias l='ls'
alias grep='grep --color=always --binary-files=without-match'
alias env+='env -0 | sort -z | tr "\0" "\n"'
alias vt='valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes '

# shell_name=$(ps -ef | grep $$ | grep -v grep | head -1 | awk '{print $8}')
shell_name=$(ps -p $$ | tail -n 1 | awk '{print $4}')
exe_name="a.out"
CC="gcc -Wall -Wextra -Werror -o $exe_name"
input_file="./$exe_name"
SLEEP=2

complete -W "fclean clean re" -o default make

shopt -s progcomp

function ld()
{
	actual_path=$(pwd)/*
	for file in $actual_path
	do
		dir="$(dirname "${file}")"
		dirname="$(basename "${file}")"
		if [[ -d $file ]]; then
			echo -e "$CYAN ./$dirname"
		fi
	done
}

function lf()
{
	actual_path=$(pwd)/*
	for file in $actual_path
	do
		dir="$(dirname "${file}")"
		filename="$(basename "${file}")"
		if [[ -f $file ]]; then
			echo -e "$GREEN $filename"
		fi
	done
}

function open()
{
	if [[ $# == 1 ]]
	then
		xdg-open $1
	else
		xdg-open .
	fi
}

function updt()
{
	sudo snap refresh
	checkupdates
	if [[ $? -eq 0 ]]
	then
		sudo pacman-mirrors -f && sudo pacman -Syyu --noconfirm
	else
		echo -e $BOLD_WHITE"----- no package to update -----"$RST
	fi
}

function cfga()
{
	if [[ $shell_name == "zsh" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.zshrc" ]; then
			code ~/.zshrc
		fi
		if [ -f "/home/$USER/.zshrc" ]; then
			code ~/.zshrc
		fi
	fi
	if [[ $shell_name == "bash" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.bashrc" ]; then
			code ~/.bashrc
		fi
		if [ -f "/home/$USER/.bashrc" ]; then
			code ~/.bashrc
		fi
	fi
	code ~/save_shortcut/.shortcut
}

function cfg()
{
	code ~/shell_function_n_shortcuts/.shortcut
}

function start()
{
	if [[ $shell_name == "zsh" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.zshrc" ]; then
			source ~/.zshrc
			echo
			echo -e "\t "$BACK_CYAN" ZSH is restarted "$RST
			echo
		fi
		if [ -f "/home/$USER/.zshrc" ]; then
			source ~/.zshrc
			echo
			echo -e "\t "$BACK_CYAN" ZSH is restarted "$RST
			echo
		fi
	fi
	if [[ $shell_name == "bash" ]]; then
		if [ -f "/mnt/nfs/homes/$USER/.bashrc" ]; then
			source ~/.bashrc
			echo
			echo -e "\t "$BACK_CYAN" BASH is restarted "$RST
			echo
		fi
		if [ -f "/home/$USER/.bashrc" ]; then
			source ~/.bashrc
			echo
			echo -e "\t "$BACK_CYAN" BASH is restarted "$RST
			echo
		fi
	fi
}

function normi()
{
	norminette | grep -vi OK

	echo ""
	nbr_error=$(norminette | grep Error! | wc -l)
	nbr_ok=$(norminette | grep OK! | wc -l)
	nbr_total=0
	let "nbr_total=$nbr_error+$nbr_ok"
	res=$(echo "scale=2; $nbr_ok / $nbr_total *100" | bc )

	echo -ne "$BOLD_RED""Error: $nbr_error \t"$RST
	echo -ne "$BOLD_GREEN""OK: $nbr_ok  \t"$RST
	echo -ne "number of files: $BOLD_WHITE$nbr_total    \t\t"$RST
	echo -ne "perc: $BOLD_WHITE$res"
	echo " %"
}

# shortcut

function commit()
{
	if [[ $# == 1 ]]; then
		git status
		echo -e "$BACK_CYAN Start commit $RST"

		git add .
		git commit -a -m $1

		echo -e "$BACK_CYAN End commit $RST"
		git status
	else
		echo -e W_ARGS
	fi
}

function poush()
{
	if [[ $# == 1 ]]; then
		make fclean

		git status
		echo -e "$BACK_GREEN Start poush $RST"

		git add .
		git commit -a -m $1
		git push

		echo -e "$BACK_GREEN End poush $RST"
		git status
	else
		echo -e W_ARGS
	fi
}

function poush_42()
{
	if [[ $# == 1 ]]; then
		date
		save=$(pwd)
		make fclean
		cd ~/42
		# cp ~/.config/Code/User/snippets/c.json .
		# cp ~/.config/Code/User/snippets/shellscript.json .
		# cp -f ~/.shortcut .
		git status
		sleep 1.5
		echo -e $BACK_GREEN" Poush "$RST
		git add ~/42/.
		git commit -a -m $1
		git push
		echo -e $BACK_GREEN" End of Poush "$RST
		git status
		cd $save
	else
		echo "missing arg"
	fi
}

function pull_42()
{
	date
	if [[ $1 == "out" ]]
	then
		a=$(pwd)
		cd ~/42
		git pull
		cd $a
	else
		cd ~/42
		git pull
	fi
	# cp -f ~/42/c.json ~/.config/Code/User/snippets/
	# cp -f ~/42/shellscript.json ~/.config/Code/User/snippets/
}

function cpl()
{
	# rm -f *.gch
	# rm -f */*.gch
	$CC -lm $@ && $input_file
}

function cpla()
{
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h && $input_file
		rm -f *.gch
		rm -f */*.gch
	else
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h && $input_file $@
		rm -f *.gch
		rm -f */*.gch
	fi

}

function cpl_all()
{
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file
		rm -f *.gch
		rm -f */*.gch
	else
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file $@
		rm -f *.gch
		rm -f */*.gch
	fi

}

function cplc()
{
	clear
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		$CC -g *.c *.h && $input_file
		rm -f *.gch
	else
		rm -f *.gch
		$CC -g *.c *.h && $input_file $@
		rm -f *.gch
	fi

}

function cplc_all()
{
	clear
	echo -e "\n"$BACK_CYAN" ----- START ----- "$RST"\n"
	if [[ $# == 0 ]]; then
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file
		rm -f *.gch
		rm -f */*.gch
	else
		rm -f *.gch
		rm -f */*.gch
		$CC -g *.c *.h */*.c */*.h && $input_file $@
		rm -f *.gch
		rm -f */*.gch
	fi
}

# if [ "${1/-*s}" != $1 ]; then
# 	$CC -D BUFFER_SIZE=42 *.c *.h */*.c */*.h && $input_file
# else
# 	$CC -D BUFFER_SIZE=42 *.c *.h && $input_file
# fi

# with args
function refresh()
{
	if [[ "$#" > 0 ]]; then
		while true; do
			tput clear
			tput cup 0 0
			echo -e $BACK_CYAN" ----- START ----- "$RST"\n"
			rm -f *.gch
			gcc -Wall -Wextra -Werror $@ && ./a.out
			echo -e "\n"
			sleep $SLEEP
		done
	else
		echo "$RED""no args $RST"
	fi
}

# all
function refresha()
{
	if [[ $# == 0 ]];
	then
		while true; do
			tput clear
			tput cup 0 0
			echo -e $BACK_CYAN" ----- START ----- "$RST"\n"
			rm -f *.gch
			gcc -Wall -Wextra -Werror *.c *.h && ./a.out
			echo -e "\n"
			sleep $SLEEP
		done
	else
		while true; do
			tput clear
			tput cup 0 0
			echo -e $BACK_CYAN" ----- START ----- "$RST"\n"
			rm -f *.gch
			gcc -Wall -Wextra -Werror *.c *.h && ./a.out $@
			echo -e "\n"
			sleep $SLEEP
		done
	fi
}

# all sub
function refresh_all()
{
	gcc -Wall -Wextra -Werror *.c */*.c
	while true; do
		tput clear
		tput cup 0 0
		echo -e $BACK_CYAN" ----- START ----- "$RST" $BACK_YELLOW $(date +"%H:%M:%S") $RST\n"
		rm -f *.gch && rm -f */*.gch
		if [[ -f "$(pwd)/a.out" ]]; then
			if [[ $# > 0 ]]
			then
				./a.out $@ && gcc -Wall -Wextra -Werror *.c */*.c
			else
				./a.out && gcc -Wall -Wextra -Werror *.c */*.c
			fi
		else
			gcc -Wall -Wextra -Werror *.c */*.c
		fi
		SECONDS=$SLEEP
		while [[ $SECONDS -ge 0 ]]; do
			tput cup 0 31; echo -e "$BACK_WHITE $SECONDS sec $RST"
			tput cup 0 31
			sleep 0.5
			let "SECONDS-=1"
		done
		rm -f *.gch && rm -f */*.gch
		echo -e "\n"
		sleep $SLEEP
	done
}

# norm refresh
function refreshn()
{
	# let "SLEEP+=2"
	SECONDS=$SLEEP
	while true; do
		nbr_lines=$(tput lines)
		nbr_lines=$(($nbr_lines-8))
		nbr_norm=$(normi | wc -l)

		tput clear
		tput cup 0 0

		echo -e "\t""$BACK_GREEN ----- ----- NORMINETTE ----- ----- $RST"


		norminette $1 | grep -vi OK | head -14

		echo ""
		nbr_error=$(norminette $1 | grep -i Error! | wc -l)
		nbr_ok=$(norminette $1 | grep -i OK! | wc -l)
		nbr_total=0
		let "nbr_total=$nbr_error+$nbr_ok"
		res=$(echo "scale=2; $nbr_ok / $nbr_total *100" | bc )

		echo -ne "$BOLD_RED""Error in $nbr_error files \t"$RST
		echo -ne "$BOLD_GREEN""OK in $nbr_ok files \t\t"$RST
		echo -ne "number of files: $BOLD_WHITE$nbr_total    \t"$RST
		echo -ne "perc: $BOLD_WHITE$res"
		echo " %"
		SECONDS=$SLEEP
		while [[ $SECONDS -ge 0 ]]; do
			tput cup 0 46; echo -e "$BACK_WHITE $SECONDS sec $RST"
			tput cup 0 45
			sleep 0.5
			let "SECONDS-=1"
		done
		# if [[ $# == 0 ]]
		# then
		# 	norm+ | head -$nbr_lines
		# else
		# 	norm+ $@ | head -$nbr_lines
		# fi
	done
}

function refreshn_test()
{
	# let "SLEEP+=2"
	SECONDS=$SLEEP
	while true; do
		nbr_lines=$(tput lines)
		nbr_lines=$(($nbr_lines-8))
		nbr_norm=$(normi | wc -l)

		tput clear
		tput cup 0 0

		echo -e "\t""$BACK_GREEN ----- ----- NORMINETTE ----- ----- $RST"

		norminette | grep -vi OK | head -14

		echo ""
		nbr_error=$(norminette | grep -i Error! | grep -vi  | wc -l)
		nbr_ok=$(norminette | grep -i OK! | grep -vi  | wc -l)
		nbr_total=0
		let "nbr_total=$nbr_error+$nbr_ok"
		res=$(echo "scale=2; $nbr_ok / $nbr_total *100" | bc )

		echo -ne "$BOLD_RED""Error in $nbr_error files \t"$RST
		echo -ne "$BOLD_GREEN""OK in $nbr_ok files \t\t"$RST
		echo -ne "number of files: $BOLD_WHITE$nbr_total    \t"$RST
		echo -ne "perc: $BOLD_WHITE$res"
		echo " %"
		SECONDS=$SLEEP
		while [[ $SECONDS -ge 0 ]]; do
			tput cup 0 46; echo -e "$BACK_WHITE $SECONDS sec $RST"
			tput cup 0 45
			sleep 0.5
			let "SECONDS-=1"
		done
		# if [[ $# == 0 ]]
		# then
		# 	norm+ | head -$nbr_lines
		# else
		# 	norm+ $@ | head -$nbr_lines
		# fi
	done
}

function clr()
{
	if [[ "${1/-f}" != $1 ]]; then
		rm -f *.gch
		rm -f a.out
		rm -rf */.vscode
		rm -rf .vscode
		clear
	else
		echo "are you sure to clear :\n_ file.gch\n_ a.out\n_ .vscode\n?\n"
		read -r answer
		if [[ $answer == "yes" || $answer == "y" ]]; then
			rm -f *.gch
			rm -f *.swp
			# rm -f */*.gch
			# rm -f */*.swp
			rm -f a.out
			rm -f $exe_name
			rm -rf .vscode
			clear
		else
			echo -e $NOTHING
		fi
	fi
}

function crt()
{
	if [[ $# == 1 ]]
	then
		if [[ ! -d "$1" ]]; then
			mkdir $1 && cd $1 && code .
		else
			echo "$1 already exist"
		fi
	else
		echo -e $W_ARGS
	fi
}
function crtf()
{
	if [[ $# == 1 ]]
	then
		if [[ ! -f "$1" ]]; then
			touch $1 && code $1
		else
			echo "$1 already exist"
		fi
	else
		echo -e $W_ARGS
	fi
}

# function
function is_in()
{
	if [[ $# == 2 ]]
	then
		big=$1
		needle=$2
		echo ${big/$needle}
		if [[ "${big/$needle}" == $big ]]
		then
			echo "nothing"
		else
			echo "something here"
		fi
	else
		echo -e $W_ARGS
	fi
}

function is_number()
{
	if ! [[ $1 =~ '^[0-9]+$' ]];
	then
		echo "error: Not a number"
		# >&2; exit 1
	fi
}

function print_arr()
{
	arr=$1
	for item in "${arr[@]}"
	do
		echo $item
	done
}

function nds()
{
	if [[ $# == 1 || $# == 2 ]]; then
		big=$1
		ext_js=".js"
		if [[ "${big/$ext_js}" == $big ]]
		then
			ext=".js"
			file=$1$ext
		else
			file=$1
		fi

		if [[ -f $file ]]; then
			echo -e "$BOLD_YELLOW$file$RST exist and it is launched with $BOLD_GREEN""node<$RST"
			if [[ $2 == "-c" ]]; then
				echo -e "and $BOLD_CYAN""vscode$RST"
				code $file
			fi
			node $file
		else
			echo -e "\n$BOLD_YELLOW$file$RST does not exist, do you want to create it ? $BOLD_YELLOW(y/n)$RST\n"
			echo -e "$RED(!) Check the path before to answer the question (!)$RST"
			echo -e "$RED--->$RST $(pwd)$RST"
			read answer
			if [[ $answer == "y" || $answer == "yes" ]]; then
				touch $file
				echo -e "\t$BOLD_YELLOW$file$RST\tcreated"
				if [[ $2 == "-c" ]]; then
					echo -e "$BOLD_YELLOW$file$RST is launch with $BOLD_BLUE""node$RST"
					code $file
				fi
			else
				echo -e "$BOLD_YELLOW""nothing happened 👒$RST"
			fi
		fi
	else
		echo -e $W_ARGS
	fi
}

# function ndst()
# {
# 	if [[ $# == 1 || $# == 2 ]]; then
# 		big=$1
# 		ext_js=".js"
# 		ext_ts=".ts"
# 		if [[ "${big/$ext_ts}" == $big ]]
# 		then
# 			ext=".ts"
# 			ts_file=$1$ext
# 		elif [[ "${big/$ext_js}" == $big ]]
# 		then
# 			ext=".js"
# 			js_file=$1$ext
# 		else
# 			file=$1
# 		fi

# 		if [[ -f $js_file ]]; then
# 			echo -e "$BOLD_YELLOW$js_file$RST exist and it is launched with $BOLD_GREEN""node$RST"
# 			if [[ $2 == "-c" ]]; then
# 				echo -e "and $BOLD_CYAN""vscode$RST"
# 				code $js_file
# 			fi
# 			if [[ "${big/$ext_ts}" == $big ]]
# 			then
# 				node $js_file
# 		else
# 			echo -e "\n$BOLD_YELLOW$file$RST does not exist, do you want to create it ? $BOLD_YELLOW(0,1,2) (no, js, ts)$RST\n"
# 			echo -e "$RED(!) Check the path before to answer the question (!)$RST"
# 			echo -e "$RED--->$RST $(pwd)$RST"
# 			read answer
# 			if [[ $answer == "1" || $answer == "2" ]]; then
# 				touch $file
# 				echo -e "\t$BOLD_YELLOW$js_file$RST\tcreated"
# 				if [[ $2 == "-c" ]]; then
# 					echo -e "$BOLD_YELLOW$js_file$RST is launch with $BOLD_BLUE""node$RST"
# 					code $js_file
# 				fi
# 			else
# 				echo -e "$BOLD_YELLOW""nothing happened 👒$RST"
# 			fi
# 		fi
# 	else
# 		echo -e $W_ARGS
# 	fi
# }

function rmv()
{
	if [[ $# == 1 ]]; then
		if echo $1 | grep -q '*'; then
			echo
		else
			if [[ -f $1 ]]
			then
				echo
				echo -e "$(file $1 | awk -F ':' '{print "\033[32;1m"$1 "\033[0m:" $2}')\t$BOLD_WHITE""size:$RST $BOLD_GREEN$(du -sh $1 | awk '{print $1}')$RST"
				echo
				echo -e "\t$BOLD_WHITE""Modify$RST\t$(stat $1 | tail -n3 | head -1 | awk '{print "\033[32m"$2}') $(stat $1 | tail -n3 | head -1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo -e "\t$BOLD_WHITE""Birth$RST\t$(stat $1 | tail -n1 | awk '{print "\033[32m"$2}') $(stat $1 | tail -n1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo
				echo -e "Do you really want to remove the file $BOLD_GREEN $1 $RST ? (y/n) ─┐"
				echo -ne "┌────────────────────────────"
				str=$1
				n=0
				while read -n1 character; do
					n=$((n+1));
					echo -n "─"
				done < <(echo -n "$str")
				echo -e "─────────────────────┘"
				echo -e "└─ path: $GREEN$(pwd)/$BOLD_GREEN$1$RST"
				sleep 3
				read answer
				if [[ $answer == "y" || $answer == "yes" ]]
				then
					echo
					echo -e $RED"/usr/bin/rm -f $1"$RST
					/usr/bin/rm -f "$1"
				else
					echo -e $NOTHING
				fi
				echo
			elif [[ -d $1 ]]
			then
				echo
				echo -e "$(file $1 | awk -F ':' '{print "\033[36;1m"$1 "\033[0m:" $2}')\t$BOLD_WHITE""size:$RST $BOLD_CYAN$(du -sh $1 | awk '{print $1}')$RST"
				echo
				echo -e "	$(stat $1 | tail -n3 | head -1 | awk '{print $1}' | awk -F ':' '{print "\033[37;1m"$1"\033[0m" $2}')\t$(stat $1 | tail -n1 | awk '{print "\033[36m"$2}') $(stat $1 | tail -n1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo -e "	$(stat $1 | tail -n1 | awk '{print $1}' | awk -F ':' '{print "\033[37;1m"$1"\033[0m" $2}')\t$(stat $1 | tail -n1 | awk '{print "\033[36m"$2}') $(stat $1 | tail -n1 | awk '{print $3}' | awk -F '.' '{print $1"\033[0m"}')"
				echo
				echo -e "Do you really want to remove the folder $BOLD_CYAN $1 $RST ? (y/n) ─┐"
				echo -ne "┌────────────────────────────"
				str=$1
				n=0
				while read -n1 character; do
					n=$((n+1));
					echo -ne "─"
				done < <(echo -n "$str")
				echo -e "───────────────────────┘"
				echo -e "└─ path: $CYAN$(pwd)/$BOLD_CYAN$1$RST"
				sleep 3
				read answer
				if [[ $answer == "y" || $answer == "yes" ]]
				then
					echo
					echo -e $RED"/usr/bin/rm -rf $1"$RST
					/usr/bin/rm -rf "$1"
				else
					echo -e $NOTHING
				fi
				echo
			else
				# echo "$1 is not a file or a directory, are you sure to delete it ?"
				echo -e "   $BOLD_WHITE~~$RST $1 is not a file or a directory $BOLD_WHITE~~$RST"
				echo -e "\t$BOLD_WHITE~~$RST are you sure to delete it ? $BOLD_WHITE~~$RST"
				sleep 3
				read answer
				if [[ $answer == 'y' || $answer == 'yes' ]]; then
					echo
					echo "rm -rf $1"
					/usr/bin/rm -rf $1
				else
					echo -e $NOTHING
				fi
			fi
		fi
	else
		echo -e $W_ARGS
	fi
}

# function too_much_time_time_to_reboot()
# {

# }

function copy()
{
	if [ -p /dev/stdin ]; then
		xclip -selection clipboard
		echo
		echo -e "\t✅ "$BACK_GREEN" copy to clipboard "$RST
		echo
	else
		echo nothing to copy...
	fi
}

function t46()
{
	FILE=$PWD"/.folder_ignore"
	if test -f "$FILE"; then
		echo ".folder_ignore exists."
		echo
	else
		echo "Which folder do you want to exclude from hcreate ? (end)"
		answer=""
		while [[ $answer != "end" ]]
		do
			read -a answer
			if [[ $answer != "end" ]]
			then
				echo $answer >> $FILE
			fi
		done
		touch $FILE
	fi
	readarray -t abc < $FILE
	for val in "${abc[@]}";
	do
		echo $val
		echo "---"
	done
	echo "------"
}

function hcreate()
{
	if [[ $# == 1 ]]
	then
		folder=$1
		header_file=$folder
		fnd=$(basename $folder)
		header_name="$(echo $fnd | tr a-z A-Z)"
		header_name="${header_name//./_}"
	else
		folder=$(basename $PWD)
		header_file="ft_$folder"".h"
		header_name="FT_$(echo $folder | tr a-z A-Z)""_H"
	fi
	date_ymd=$(date +%Y/%m/%d)
	date_hms=$(date +%H:%M:%S)
	save_created="nothing"
	if [ -f $header_file ]
	then
		if [[ $(cat $header_file | wc -m) -gt 0 ]]
		then
			save_created=$(sed -n '/Created/{p;};x' $header_file)
		fi
	fi

	save_struct="nothing"
	save_include="nothing"
	save_define="nothing"
	if [ -f $header_file ]
	then
		result_struct=$(cat $header_file | grep -q typedef | wc -l)
		cat $header_file | grep -q typedef
		if cat $header_file | grep -q typedef;
		then
			if cat $header_file | grep -onq "// ------------------------------ struct ------------------------------------ //";
			then
				start_struct=$(cat $header_file | grep -on --color=never "// ------------------------------ struct ------------------------------------ //" | awk -F ':' '{print $1}')
				end_struct=$(cat $header_file | grep -on --color=never "// ---------------------------- end struct ---------------------------------- //" | awk -F ':' '{print $1}')
				IFS=$'\n'
				save_struct=($(sed -n "$start_struct,$end_struct p" $header_file))
			fi
		fi

		if cat $header_file | grep -onq "// ------------------------------ include ----------------------------------- //";
		then
			start_include=$(cat $header_file | grep -on --color=never "// ------------------------------ include ----------------------------------- //" | awk -F ':' '{print $1}')
			end_include=$(cat $header_file | grep -on --color=never "// ---------------------------- end include --------------------------------- //" | awk -F ':' '{print $1}')
			IFS=$'\n'
			save_include=($(sed -n "$start_include,$end_include p" $header_file))
		fi

		if cat $header_file | grep -onq "// ------------------------------ define ------------------------------------ //";
		then
			start_define=$(cat $header_file | grep -on --color=never "// ------------------------------ define ------------------------------------ //" | awk -F ':' '{print $1}')
			end_define=$(cat $header_file | grep -on --color=never "// ---------------------------- end define ---------------------------------- //" | awk -F ':' '{print $1}')
			IFS=$'\n'
			save_define=($(sed -n "$start_define,$end_define p" $header_file))
		fi
	else
		echo "nothing"
	fi

	##### ERASE #####
	> $header_file;

	##### str_name #####
	str_name="/*   $header_file"
	nbr_char=${#str_name}
	nbr_char=$(($nbr_char + 24))
	while [[ $nbr_char -lt 80 ]]
	do
		str_name="$str_name "
		nbr_char=$(($nbr_char + 1))
	done
	str_name="$str_name:+:      :+:    :+:   */"

	##### by #####
	str_by="/*   By: $(whoami) <$(whoami)@student.42.fr>"
	nbr_char=${#str_by}
	nbr_char=$(($nbr_char + 28))
	while [[ $nbr_char -lt 80 ]]
	do
		str_by="$str_by "
		nbr_char=$(($nbr_char + 1))
	done
	str_by="$str_by+#+  +:+       +#+        */"

	##### created #####
	str_created="/*   Created: $date_ymd $date_hms by $(whoami)"
	nbr_char=${#str_created}
	nbr_char=$(($nbr_char + 25))
	while [[ $nbr_char -lt 80 ]]
	do
		str_created="$str_created "
		nbr_char=$(($nbr_char + 1))
	done
	str_created="$str_created#+#    #+#             */"

	##### updated #####
	str_updated="/*   Updated: $date_ymd $date_hms by $(whoami)"
	nbr_char=${#str_updated}
	nbr_char=$(($nbr_char + 26))
	while [[ $nbr_char -lt 80 ]]
	do
		str_updated="$str_updated "
		nbr_char=$(($nbr_char + 1))
	done
	str_updated="$str_updated###   ########.fr       */"

	echo "/* ************************************************************************** */" >> $header_file
	echo "/*                                                                            */" >> $header_file
	echo "/*                                                        :::      ::::::::   */" >> $header_file
	echo "$str_name" >> $header_file
	echo "/*                                                    +:+ +:+         +:+     */" >> $header_file
	echo "$str_by" >> $header_file
	echo "/*                                                +#+#+#+#+#+   +#+           */" >> $header_file
	if [[ $save_created == "nothing" ]]
	then
		echo "$str_created" >> $header_file
	else
		echo "$save_created" >> $header_file
	fi
	echo "$str_updated" >> $header_file
	echo "/*                                                                            */" >> $header_file
	echo "/* ************************************************************************** */" >> $header_file

	echo -e "\n#ifndef $header_name" >> $header_file
	echo -e "# define $header_name\n" >> $header_file

	echo "# include <dirent.h>" >> $header_file
	echo "# include <errno.h>" >> $header_file
	echo "# include <fcntl.h>" >> $header_file
	echo "# include <limits.h>" >> $header_file
	echo "# include <pthread.h>" >> $header_file

	echo "# include <sys/types.h>" >> $header_file
	echo "# include <sys/time.h>" >> $header_file
	echo "# include <sys/resource.h>" >> $header_file
	echo "# include <sys/wait.h>" >> $header_file
	echo "# include <sys/stat.h>" >> $header_file
	echo "# include <sys/ioctl.h>" >> $header_file

	echo "# include <signal.h>" >> $header_file
	echo "# include <stdarg.h>" >> $header_file
	echo "# include <stddef.h>" >> $header_file
	echo "# include <stdarg.h>" >> $header_file
	echo "# include <stdio.h>" >> $header_file
	echo "# include <stdlib.h>" >> $header_file
	echo "# include <string.h>" >> $header_file
	echo "# include <termios.h>" >> $header_file
	echo "# include <unistd.h>" >> $header_file

	echo "# include <readline/readline.h>" >> $header_file
	echo "# include <readline/history.h>" >> $header_file

	echo "" >> $header_file

	##### save_include #####
	if [[ $save_include != "nothing" ]]
	then
		for val in "${save_include[@]}";
		do
			if [[ "$val" == *"typedef"* ]]
			then
				echo -e "\n$val" >> $header_file
			else
				echo "$val" >> $header_file
			fi
		done
		echo "" >> $header_file
	else
		echo "// ------------------------------ include ----------------------------------- //" >> $header_file
		echo "// ---------------------------- end include --------------------------------- //" >> $header_file
		echo "" >> $header_file
	fi
	##### end_place_include #####

	##### save_define #####
	if [[ $save_define != "nothing" ]]
	then
		for val in "${save_define[@]}";
		do
			echo "$val" >> $header_file
		done
		echo "" >> $header_file
	else
		echo "// ------------------------------ define ------------------------------------ //" >> $header_file
		echo "// ---------------------------- end define ---------------------------------- //" >> $header_file
		echo "" >> $header_file
	fi
	##### end_place_define #####

	struct_type=()
	##### save struct #####
	if [[ $save_struct != "nothing" ]]
	then
		last_comment=0
		for val in "${save_struct[@]}";
		do
			if [[ "$val" == *"typedef"* || "$val" == *"enum e_"* ]]
			then
				if [[ $last_comment == "1" ]]
				then
					echo -e "$val" >> $header_file
					last_comment=0
				else
					echo -e "\n$val" >> $header_file
				fi
			else
				if [[ $val == *"}"* ]];
				then
					res=`echo $val | tr -d '\t' | tr -d '}' | tr -d ';'`
					if [[ "$res" =~ [A-Za-z] ]]; then
						# echo $res
						struct_type+=( "$res" )
					fi
				fi
				echo "$val" >> $header_file
			fi
			if echo $val | grep -q "// ---------------------------- "
			then
				if echo $val | grep -vq "// ---------------------------- end"
				then
					last_comment=1
				fi
			fi
		done
		echo "" >> $header_file
	else
		echo "// ------------------------------ struct ------------------------------------ //" >> $header_file
		echo "// ---------------------------- end struct ---------------------------------- //" >> $header_file
		echo "" >> $header_file
	fi
	# if [[ ${#struct_type[@]} -eq 0 ]]
	# then
	# 	printf "struct_type array is empty\n"
	# fi
	##### end_place_struct #####

	##### get_function #####
	IFS=$'\n'
	functions=($(find . -type f -name '*.[ch]' -exec ctags -x --c-kinds=f {} ';' | awk '{
		if ($4 ~ "minilibx" || $4 ~ "libft")
		{
			next;
		}
		else
		{
			print $4;
			$1=$2=$3=$4="";
			print $0;
		}
	}'))

	for val in "${functions[@]}";
	do
		if [[ $val != *"main("* ]]
		then
			if [[ $(cat $header_file | grep -on "$val" --color=never | wc -l) -eq 0 ]]
			then
				echo $val >> $header_file
			fi
		fi
	done
	###	add this snippet between if and else if you want to exclude a folder (ex:minilibx)
	#
	#	else if ($4 ~ "minilibx")
	#	{
	#		next;
	#	}
	if [[ $(cat $header_file | grep "main(" | wc -l) -eq 1 ]]
	then
		lnbr_main=$(cat $header_file | grep "main(" -n --color=never | awk -F ':' '{print $1}')
		lnbr_main=$(($lnbr_main-1))
		# sed -i "$lnbr_main d" $header_file
		# sed -i "$lnbr_main d" $header_file
	elif [[ $(cat $header_file | grep "main(" | wc -l) -gt 1 ]]
	then
		echo "error detected (script continue)"
		# echo "two function main(... detected"
	fi


	#---- a faire : find max length of all type present -> define number of tab for each type (basics + struct) for norm ----#


	# norm with type in header
	sed -i '/static /d' $header_file
	sed -i '/main(/d' $header_file
	sed -i 's/\.\//\/\//' $header_file
	sed -i 's/\.\/\//\.\.\//' $header_file
	sed -i ':a;N;$!ba;s/)\n/);\n/g' $header_file
	sed -i ':a;N;$!ba;s/)$/);/g' $header_file
	sed -i ':a;N;$!ba;s/\n\ \ \ \ /\n/g' $header_file
	sed -i ':a;N;$!ba;s/\nvoid\ /\nvoid\t/g' $header_file
	sed -i ':a;N;$!ba;s/\ndouble\ /\ndouble\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nint\ /\nint\t\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nsize_t\ /\nsize_t\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nchar\ /\nchar\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nlong\ int\ /\nlong\ int\t\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nunsigned\ int\ /\nunsigned\ int\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nunsigned\ char\ /\nunsigned\ char\t/g' $header_file
	sed -i ':a;N;$!ba;s/\nlong\ long\ int\ /\nlong\ long\ int\t/g' $header_file

	touch "$PWD/sh.sh"
	for val in "${struct_type[@]}";
	do
		start="\n$val\ "
		res="sed -i '"
		res=$res':a;N;$!ba;s/'
		res=$res$start
		res=$res"/"
		res=$res"\n$val\t"
		res=$res"/g' $header_file"
		echo $res >> "$PWD/sh.sh"
		echo "" >> "$PWD/sh.sh"
	done
	source "$PWD/sh.sh"
	/usr/bin/rm "$PWD/sh.sh"


	echo "" >> $header_file
	echo -n "#endif" >> $header_file
}

function mcreate()
{
	# folder to search C file
	# if [[ $# == 1 ]]
	# then

	# else

	# fi

	if cat Makefile | grep -onq "# ----------------------------------- srcs ----------------------------------- #";
	then
		start_srcs=$(cat Makefile | grep -on --color=never "# ----------------------------------- srcs ----------------------------------- #" | awk -F ':' '{print $1}')
		end_srcs=$(cat Makefile | grep -on --color=never "# --------------------------------- end srcs --------------------------------- #" | awk -F ':' '{print $1}')
		IFS=$'\n'
		last_line=$(cat Makefile | wc -l)


		mid1_srcs=$start_srcs
		let "mid1_srcs-=1"

		mid2_srcs=$end_srcs
		let "mid2_srcs+=1"


		save_first_part=($(sed -n "1,$mid1_srcs p" Makefile))
		save_srcs=($(sed -n "$start_srcs,$end_srcs p" Makefile))
		save_last_part=($(sed -n "$mid2_srcs,$last_line p" Makefile))

		> new_makefile
		for val in "${save_first_part[@]}";
		do
			if echo $val | grep -qi "###"
			then
				echo "" >> new_makefile
			fi
			echo "$val" >> new_makefile
		done
		echo "" >> new_makefile
		echo "# ----------------------------------- srcs ----------------------------------- #" >> new_makefile
		file_struct=(`ls srcs/*.c`)
		ite=0
		len=${#file_struct[*]}
		let "len-=1"
		for val in "${file_struct[@]}";
		do
			val=$(basename $val)
			if [[ $ite -eq 0 ]]
			then
				echo -e "_SRCS	=	$val \\" >> new_makefile
			elif [[ $ite == $len ]]
			then
				echo -e "\t\t\t$val" >> new_makefile
			else
				echo -e "\t\t\t$val \\" >> new_makefile
			fi
			let "ite+=1"
		done
		echo "# --------------------------------- end srcs --------------------------------- #" >> new_makefile
		echo "" >> new_makefile
		for val in "${save_last_part[@]}";
		do
			if echo $val | grep -qi "###"
			then
				echo "" >> new_makefile
			fi
			if echo $val | grep -qvi "=" | grep -qi ":"
			then
				echo "" >> new_makefile
			fi
			echo "$val" >> new_makefile
		done
		echo "" >> new_makefile
		echo "" >> new_makefile

		mv -f new_makefile Makefile
	fi
}

function mcreate_cpp()
{
	# folder to search C file
	# if [[ $# == 1 ]]
	# then

	# else

	# fi

	if cat Makefile | grep -onq "# ----------------------------------- srcs ----------------------------------- #";
	then
		start_srcs=$(cat Makefile | grep -on --color=never "# ----------------------------------- srcs ----------------------------------- #" | awk -F ':' '{print $1}')
		end_srcs=$(cat Makefile | grep -on --color=never "# --------------------------------- end srcs --------------------------------- #" | awk -F ':' '{print $1}')
		IFS=$'\n'
		last_line=$(cat Makefile | wc -l)


		mid1_srcs=$start_srcs
		let "mid1_srcs-=1"

		mid2_srcs=$end_srcs
		let "mid2_srcs+=1"


		save_first_part=($(sed -n "1,$mid1_srcs p" Makefile))
		save_srcs=($(sed -n "$start_srcs,$end_srcs p" Makefile))
		save_last_part=($(sed -n "$mid2_srcs,$last_line p" Makefile))

		> new_makefile
		for val in "${save_first_part[@]}";
		do
			if echo $val | grep -qi "###"
			then
				echo "" >> new_makefile
			fi
			echo "$val" >> new_makefile
		done
		echo -e "" >> new_makefile
		echo -e "# ----------------------------------- srcs ----------------------------------- #" >> new_makefile
		file_struct=(`ls src/*.cpp`)
		ite=0
		len=${#file_struct[*]}
		let "len-=1"
		for val in "${file_struct[@]}";
		do
			val=$(basename $val)
			if [[ $ite -eq 0 ]]
			then
				echo -e "SRC	=	$val \\" >> new_makefile
			elif [[ $ite == $len ]]
			then
				echo -e "\t\t$val" >> new_makefile
			else
				echo -e "\t\t$val \\" >> new_makefile
			fi
			let "ite+=1"
		done
		echo "# --------------------------------- end srcs --------------------------------- #" >> new_makefile
		echo "" >> new_makefile
		for val in "${save_last_part[@]}";
		do
			if echo $val | grep -qi "###"
			then
				echo "" >> new_makefile
			fi
			if echo $val | grep -qvi "=" | grep -qi ":"
			then
				echo "" >> new_makefile
			fi
			echo "$val" >> new_makefile
		done
		echo "" >> new_makefile
		echo "" >> new_makefile

		mv -f new_makefile Makefile
	fi
}

function mcreate_hpp()
{
	# folder to search C file
	# if [[ $# == 1 ]]
	# then

	# else

	# fi

	if cat Makefile | grep -onq "#---------------------------------- headers -----------------------------------#";
	then
		start_hpp=$(cat Makefile | grep -on --color=never "#---------------------------------- headers -----------------------------------#" | awk -F ':' '{print $1}')
		end_hpp=$(cat Makefile | grep -on --color=never "#-------------------------------- end headers ---------------------------------#" | awk -F ':' '{print $1}')
		IFS=$'\n'
		last_line=$(cat Makefile | wc -l)


		mid1_hpp=$start_hpp
		let "mid1_hpp-=1"

		mid2_hpp=$end_hpp
		let "mid2_hpp+=1"


		save_first_part=($(sed -n "1,$mid1_hpp p" Makefile))
		save_hpp=($(sed -n "$start_hpp,$end_hpp p" Makefile))
		save_last_part=($(sed -n "$mid2_hpp,$last_line p" Makefile))

		> new_makefile
		for val in "${save_first_part[@]}";
		do
			if echo $val | grep -qi "###"
			then
				echo "" >> new_makefile
			fi
			echo "$val" >> new_makefile
		done
		echo "" >> new_makefile
		echo "#---------------------------------- headers -----------------------------------#" >> new_makefile
		file_struct=(`ls includes/*.hpp`)
		ite=0
		len=${#file_struct[*]}
		let "len-=1"
		echo -e "HEAD = \$(addprefix \$(HEADER_DIR), \\" >> new_makefile
		for val in "${file_struct[@]}";
		do
			val=$(basename $val)
			echo -e "\t\t$val \\" >> new_makefile
			let "ite+=1"
		done
		echo -e ")" >> new_makefile
		echo "#-------------------------------- end headers ---------------------------------#" >> new_makefile
		echo "" >> new_makefile
		for val in "${save_last_part[@]}";
		do
			if echo $val | grep -qi "###"
			then
				echo "" >> new_makefile
			fi
			if echo $val | grep -qvi "=" | grep -qi ":"
			then
				echo "" >> new_makefile
			fi
			echo "$val" >> new_makefile
		done
		echo "" >> new_makefile
		echo "" >> new_makefile

		mv -f new_makefile Makefile
	fi
}

function go()
{
	exc=$(find . -type f -executable)
	clear && mcreate_cpp && mcreate_hpp && make re && clear && $exc
}

function hppc()
{
	name=""
	if [[ $# != 0 ]]
	then
		for var in "$@"
		do
			word=$var
			word=$(echo "$word" | tr '[:upper:]' '[:lower:]')
			word=${word^}
			name=$name$word
		done
		header_name="$(echo $name | tr a-z A-Z)""_HPP"
		header_file="$name"".hpp"
		cpp_file="$name"".cpp"
	else
		echo -e $W_ARGS
		return 1;
	fi

	##### ERASE #####
	> $header_file;

	##### str_name #####
	str_name="/*   $header_file"
	nbr_char=${#str_name}
	nbr_char=$(($nbr_char + 24))
	while [[ $nbr_char -lt 80 ]]
	do
		str_name="$str_name "
		nbr_char=$(($nbr_char + 1))
	done
	str_name="$str_name:+:      :+:    :+:   */"

	##### by #####
	str_by="/*   By: $(whoami) <$(whoami)@student.42.fr>"
	nbr_char=${#str_by}
	nbr_char=$(($nbr_char + 28))
	while [[ $nbr_char -lt 80 ]]
	do
		str_by="$str_by "
		nbr_char=$(($nbr_char + 1))
	done
	str_by="$str_by+#+  +:+       +#+        */"

	##### created #####
	date_ymd=$(date +%Y/%m/%d)
	date_hms=$(date +%H:%M:%S)
	save_created="nothing"
	if [ -f $header_file ]
	then
		if [[ $(cat $header_file | wc -m) -gt 0 ]]
		then
			save_created=$(sed -n '/Created/{p;};x' $header_file)
		fi
	fi
	str_created="/*   Created: $date_ymd $date_hms by $(whoami)"
	nbr_char=${#str_created}
	nbr_char=$(($nbr_char + 25))
	while [[ $nbr_char -lt 80 ]]
	do
		str_created="$str_created "
		nbr_char=$(($nbr_char + 1))
	done
	str_created="$str_created#+#    #+#             */"

	##### updated #####
	str_updated="/*   Updated: $date_ymd $date_hms by $(whoami)"
	nbr_char=${#str_updated}
	nbr_char=$(($nbr_char + 26))
	while [[ $nbr_char -lt 80 ]]
	do
		str_updated="$str_updated "
		nbr_char=$(($nbr_char + 1))
	done
	str_updated="$str_updated###   ########.fr       */"

	echo "/* ************************************************************************** */" >> $header_file
	echo "/*                                                                            */" >> $header_file
	echo "/*                                                        :::      ::::::::   */" >> $header_file
	echo "$str_name" >> $header_file
	echo "/*                                                    +:+ +:+         +:+     */" >> $header_file
	echo "$str_by" >> $header_file
	echo "/*                                                +#+#+#+#+#+   +#+           */" >> $header_file
	if [[ $save_created == "nothing" ]]
	then
		echo "$str_created" >> $header_file
	else
		echo "$save_created" >> $header_file
	fi
	echo "$str_updated" >> $header_file
	echo "/*                                                                            */" >> $header_file
	echo "/* ************************************************************************** */" >> $header_file

	echo -e "\n#ifndef $header_name" >> $header_file
	echo -e "# define $header_name\n" >> $header_file

	echo -e "#include <string>" >> $header_file
	echo -e "#include <cstdlib>" >> $header_file
	echo -e "#include <iomanip>" >> $header_file
	echo -e "#include <csignal>" >> $header_file
	echo -e "#include <iostream>" >> $header_file

	echo -e "" >> $header_file

	echo -e "class $name"												>> $header_file
	echo -e "{"															>> $header_file
	echo -e "\tpublic:"													>> $header_file
	echo -e "\t\t$name(); // canonical form" 							>> $header_file
	echo -e "\t\t$name(const $name&src); // canonical form"				>> $header_file
	echo -e "\t\t$name&operator=(const $name&src); // canonical form"	>> $header_file
	echo -e "\t\t~$name(); // canonical form"							>> $header_file
	echo -e ""															>> $header_file
	echo -e "\t\t// methods"												>> $header_file
	echo -e ""															>> $header_file
	echo -e "\t\t// getter"												>> $header_file
	echo -e ""															>> $header_file
	echo -e "\t\t// setter"												>> $header_file
	echo -e ""															>> $header_file
	echo -e "\tprivate:"												>> $header_file
	echo -e "\t\tstd::string\tname;"									>> $header_file
	echo -e "};"														>> $header_file
	echo -e ""															>> $header_file

	echo -e "#endif" >> $header_file


	echo "/* ************************************************************************** */" >> $cpp_file
	echo "/*                                                                            */" >> $cpp_file
	echo "/*                                                        :::      ::::::::   */" >> $cpp_file
	echo "$str_name" >> $cpp_file
	echo "/*                                                    +:+ +:+         +:+     */" >> $cpp_file
	echo "$str_by" >> $cpp_file
	echo "/*                                                +#+#+#+#+#+   +#+           */" >> $cpp_file
	if [[ $save_created == "nothing" ]]
	then
		echo "$str_created" >> $cpp_file
	else
		echo "$save_created" >> $cpp_file
	fi
	echo "$str_updated" >> $cpp_file
	echo "/*                                                                            */" >> $cpp_file
	echo "/* ************************************************************************** */" >> $cpp_file

	echo -e "\n#include \"../includes/$header_file\"\n" >> $cpp_file

	echo -e "// canonical form" >> $cpp_file
	echo -e "$name::$name(void)" >> $cpp_file
	echo -e "{" >> $cpp_file
	echo -e "	std::cout << \"$name Constructor called\" << std::endl;" >> $cpp_file
	echo -e "}" >> $cpp_file
	echo -e "" >> $cpp_file

	echo -e "$name::$name(const $name& src)" >> $cpp_file
	echo -e "{" >> $cpp_file
	echo -e "	std::cout << \"Copy $name constructor called\" << std::endl;" >> $cpp_file
	echo -e "	*this = src;" >> $cpp_file
	echo -e "}" >> $cpp_file

	echo -e "$name& $name::operator=(const $name& src)" >> $cpp_file
	echo -e "{" >> $cpp_file
	echo -e "	std::cout << \"Overload $name operator called\" << std::endl;" >> $cpp_file
	echo -e "	(void)src;" >> $cpp_file
	echo -e "	return (*this);" >> $cpp_file
	echo -e "}" >> $cpp_file

	echo -e "$name::~$name(void)" >> $cpp_file
	echo -e "{" >> $cpp_file
	echo -e "	std::cout << \"$name Destructor called\" << std::endl;" >> $cpp_file
	echo -e "}" >> $cpp_file
	echo -e "" >> $cpp_file

}

function clean_cpp()
{
	if [[ $(basename $PWD) == "module_0"* ]]
	then
		echo here !
		LSL=$(ls)

		declare -a MYRA
		MYRA=($LSL)
		for val in "${MYRA[@]}";
		do
			echo -e $BACK_CYAN" ----- $val ----- "$RST
			cd $val
			make re
			make fclean
			cd ..
		done
	else
		echo not in module_0X...
	fi
}

function clean_exo()
{
	if [[ $(basename $PWD) == "ex0"* ]]
	then
		echo here !
		LSL=$(ls *.cpp)

		declare -a arr_cpp
		arr_cpp=($LSL)
		for val in "${arr_cpp[@]}";
		do
			echo -e $BOLD_CYAN" $val moved to src "$RST
			mv $val src/.
		done

		LSL=$(ls *.hpp)

		declare -a arr_hpp
		arr_hpp=($LSL)
		for val in "${arr_hpp[@]}";
		do
			echo -e $BOLD_PURPLE" $val moved to includes "$RST
			mv $val includes/.
		done
	else
		echo not in module_0X...
	fi
}

function rn_limit()
{
	echo fs.inotify.max_user_watches=524288 | sudo tee -a /etc/sysctl.conf && sudo sysctl -p
}

function nbr_func()
{
	if [[ $# == 1 ]]
	then
		# echo arg
		# files=$(ls $1*.c)
		echo "work in progress..."
	else
		# echo alone
		# files=($(ls *.c))
		functions=($(find . -type f -name '*.[ch]' -exec ctags -x --c-kinds=f {} ';' | awk '{
			if ($4 ~ "minilibx" || $4 ~ "libft")
			{
				next;
			}
			else
			{
				print $4;
				$1=$2=$3=$4="";
				print $0;
			}
		}'))
	fi
	filename="_nbr_func"
	> $filename
	filename_2="_nbr_func_2"
	> $filename_2
	count=-1
	actual_fct="${functions[0]}"
	echo
	echo -e "\t$UNDER_WHITE Nbr of functions by file $RST"
	echo
	for val in "${functions[@]}";
	do
		if [[ $val != *"main("* ]]
		then
			if [[ $val == "./"* ]]
			then
				# echo $val
				let "count+=1"
			fi
			if [[ $val == "./"* && $val != *"$actual_fct"* ]]
			then

				touch "$PWD/sh.sh"

				start="$actual_fct"
				res="sed -i '"
				res=$res':a;N;$!ba;s|'
				res=$res$start
				res=$res"|"
				res=$res"$actual_fct    $count"
				res=$res"|g' $filename"

				echo $res >> "$PWD/sh.sh"
				echo "" >> "$PWD/sh.sh"

				source "$PWD/sh.sh"
				/usr/bin/rm "$PWD/sh.sh"

				n=40
				reset=$(tput sgr0)
				yellow=$(tput setaf 3)
				back_yellow=$(tput setab 3)
				green=$(tput setaf 2)
				back_green=$(tput setab 2)
				red=$(tput setaf 1)
				back_red=$(tput setab 1)
				if [[ $count -eq 5 ]]
				then

					# printf "%-${n}.${n}s %s\n" "${yellow}$actual_fct " "${back_yellow} $count ${reset}"
					printf "%-${n}.${n}s %s\n" "$actual_fct " " $count " >> $filename
					# echo -e $YELLOW "$actual_fct\t$BOLD_YELLOW$count$YELLOW functions" $RST
				elif [[ $count -gt 5 ]]
				then

					# printf "%-${n}.${n}s %s\n" "${red}$actual_fct " "${back_red} $count ${reset}"
					printf "%-${n}.${n}s %s\n" "$actual_fct " " $count " >> $filename
					# echo -e $RED "$actual_fct\t$BOLD_RED$count$RED functions" $RST
				elif [[ $count -lt 5 ]]
				then

					# printf "%-${n}.${n}s %s\n" "${green}$actual_fct " "${back_green} $count ${reset}"
					printf "%-${n}.${n}s %s\n" "$actual_fct " " $count " >> $filename
					# echo -e $GREEN "$actual_fct\t$BOLD_GREEN$count$GREEN functions" $RST
				fi
				echo "$actual_fct    $count" >> $filename_2
				actual_fct=$val
				count=0
			fi

			# ------------------------ >> WITH FILE << ------------------------

			if [[ $(cat $filename | grep -on "$val" --color=never | wc -l) -eq 0 ]]
			then
				echo $val >> $filename_2
				# if [[ $val != "./"* ]]
				# then
				# 	echo $val >> $filename_2
				# fi
			fi
		fi
	done

	final_file=($(sort $filename))
	for val in "${final_file[@]}";
	do
		number=$(echo $val | tail -c4 | tr -d -c 0-9)
		# echo $number
		if [[ $number -eq 5 ]]
		then
			echo -e $YELLOW $val | head -c40
			echo -e "$BACK_YELLOW $number $RST"
		elif [[ $number -gt 5 ]]
		then
			echo -e $RED $val | head -c40
			echo -e "$BACK_RED $number $RST"
		elif [[ $number -lt 5 ]]
		then
			echo -e $GREEN $val | head -c40
			echo -e "$BACK_GREEN $number $RST"
		fi
	done
	echo
	# cat $filename
	# for val in "${functions[@]}";
	# do
	# 	echo $val
	# 	echo ----
	# done
	# find . -type f -name '*.[ch]' -exec ctags -x --c-kinds=f {} ';'
}


function hm()
{
	if [[ $# == 1 ]]
	then
		hcreate $1 && mcreate
	else
		hcreate && mcreate
	fi
}

function cub2()
{
	cd ~/cub2d
	hcrt=""
	mcrt=""
	mk="make"
	or=""
	gdb=""
	if [[ $# == 1 ]]
	then
		if [[ "${1/h}" != $1 ]]
		then
			hcrt=" hcreate incs/cub3D.h "
		fi
		if [[ "${1/m}" != $1 && "${1/h}" != $1 ]]
		then
			mcrt+=" && "
		fi
		if [[ "${1/m}" != $1 ]]
		then
			mcrt+=" mcreate "
		fi
		if [[ "${1/m}" != $1 || "${1/h}" != $1 ]]
		then
			or+=" && "
		fi
		if [[ "${1/g}" != $1 ]]
		then
			gdb=" gdb --args "
		elif [[ "${1/v}" != $1 ]]
		then
			gdb=" valgrind --leak-check=full --track-origins=yes"
		fi
		if [[ "${1/r}" != $1 ]]
		then
			mk+=" re"
		fi
	fi
	if [[ $# == 2 ]]
	then
		clear
		eval "$hcrt$mcrt$or $mk && clear && $gdb ./cub3D $2"
		echo
		echo "$hcrt$mcrt$or $mk && clear && $gdb ./cub3D $2"
	else
		clear
		eval "$hcrt$mcrt$or $mk && clear && $gdb ./cub3D maps/trois.cub"
		echo
		echo "$hcrt$mcrt$or $mk && clear && $gdb ./cub3D maps/trois.cub"
	fi
	# hcreate incs/cub3D.h && mcreate && make && valgrind --leak-check=full --show-leak-kinds=all ./cub3D
	# hcreate incs/cub3D.h && mcreate && make && clear && ./cub3D maps/map2.cub
}

function cub()
{

	cmd="cd ~/cub3d && clear "

	h=""
	r=""
	m=""
	g=""
	v=""
	# big=$1
	# needle="r"
	if [[ $# -ge 1 ]]
	then
		if [[ "${1/'g'}" != $1 && "${1/'v'}" != $1 ]]
		then
			echo -e $RED"something wrong"$RST
			exit 0
		fi
		if [[ "${1/'h'}" != $1 ]]
		then
			h=" && hcreate incs/cub3D.h "
		fi
		if [[ "${1/'m'}" != $1 ]]
		then
			m=" && mcreate "
		fi
		if [[ "${1/'r'}" != $1 ]]
		then
			r=" && make re"
		else
			r=" && make"
		fi
		if [[ "${1/'v'}" != $1 && "${1/'g'}" == $1 ]]
		then
			v="valgrind --leak-check=full --show-leak-kinds=all --track-origins=yes "
		elif [[ "${1/'g'}" != $1 && "${1/'v'}" == $1 ]]
		then
			g="gdb"
		fi
	fi
	if [[ $# == 1 ]]
	then
		total=$cmd$h$m$r" && clear && "$v$g" ./cub3D maps/map2.cub"
		eval $total
		# echo
		# echo $total
		# echo
	elif [[ $# == 2 ]]
	then
		total=$cmd$h$m$r" && clear && "$v$g" ./cub3D $2"
		eval $total
		# echo
		# echo $total
		# echo
	elif [[ $# == 0 ]]
	then
		total=$cmd$h$m$r" && clear && "$v$g" ./cub3D maps/map2.cub "
		# echo
		# echo $total
		# echo
	fi
}

function vlg()
{
	echo -e $BOLD_WHITE"\tvalgrind"$RST
	echo "--show-leak-kinds=all"
	echo "--leak-check=<no|summary|yes|full>"
	echo "--track-origins=<yes|no>"
	echo "--track-fds=<yes|no|all>"
}

function kill_search()
{
	if [[ $# == 1 ]]
	then
		if top -bn1 | grep --color=never -iq $1
		then
			pid=$(top -bn1 -o +%MEM | grep --color=never -i $1 | head -1 | awk '{print $1}')
			name=$(top -bn1 -o +%MEM | grep --color=never -i $1 | head -1 | awk '{print $12}')
			echo -e "do you want to kill $RED$name$RST    with pid: $RED$pid$RST ? (y/n)"
			read answer
			if [[ $answer == "y" ]]
			then
				kill -9 $pid
				echo -e $BOLD_RED"$name$RED was killed"$RST
			else
				echo -e $NOTHING
			fi
		else
			echo -e "nothing found"
		fi
	else
		echo -e $W_ARGS
	fi
}

function high_mem()
{
	line="$(top -bn1 -o +%MEM | head -n 8 | tail -1)"
	pid="$(top -bn1 -o +%MEM | head -n 8 | tail -1 | awk '{print $1}')"
	task_name="$(top -bn1 -o +%MEM | head -n 8 | tail -1 | awk '{print $12}')"
	echo -e $line
	if [[ $task_name != "plasmashell" && $task_name != "kwin_x11" ]]; then
		echo -e "$BOLD_RED "$task_name" was killed $RST"
		kill -9 $pid
	else
		echo -e "$BOLD_YELLOW""nothing happened 👒$RST"
	fi
}

function high_cpu()
{
	line="$(top -bn1 -o +%CPU | head -n 8 | tail -1)"
	pid="$(top -bn1 -o +%CPU | head -n 8 | tail -1 | awk '{print $1}')"
	task_name="$(top -bn1 -o +%CPU | head -n 8 | tail -1 | awk '{print $12}')"
	echo -e $line
	if [[ $task_name != "plasmashell" && $task_name != "kwin_x11" ]]; then
		echo -e "$BOLD_RED "$task_name" was killed $RST"
		kill -9 $pid
	else
		echo -e "$BOLD_YELLOW""nothing happened 👒$RST"
	fi
}

function vmem()
{
	if [ -z "$1" ]; then
		# echo "5 most task memory used"
		top -bn1 -o %MEM | head -n 12 | tail -7
	else
		# echo "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		top -bn1 -o %MEM | head -n $hd | tail -$tl
		# echo "hd "$hd
		# echo "start "$start
	fi
}
function vcpu()
{
	if [ -z "$1" ]; then
		# echo "5 most task memory used"
		top -bn1 -o %CPU | head -n 12 | tail -7
	else
		# echo "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		top -bn1 -o %CPU | head -n $hd | tail -$tl
		# echo "hd "$hd
		# echo "start "$start
	fi
}
function vstat()
{
	if [ -z "$1" ]; then
		# "5 most task memory used"
		echo -e "$BLUE\e[4m CPU $BLUE"
		top -bn1 -o %CPU | head -n 12 | tail -7
		echo -e "$GREEN\e[4m MEM $GREEN"
		top -bn1 -o %MEM | head -n 12 | tail -7
	else
		# "with arg"
		tl=$1
		hd=5
		let "tl+=2"
		let "hd+=tl"
		echo -e "$BLUE\e[4m CPU $BLUE"
		top -bn1 -o %CPU | head -n $hd | tail -$tl
		echo -e "$GREEN\e[4m MEM $GREEN"
		top -bn1 -o %MEM | head -n $hd | tail -$tl
	fi
}

function pull_f()
{
	git add . && git stash && git pull
}

function scan()
{
	compile=0
	if [ -f "$(pwd)/Makefile" ]
	then
		compile=1
		scan-build make re
	else
		compile=1
		c_at_root=$(ls *.c | wc -l)
		c_in_sub=$(ls */*.c | wc -l)
		h_at_root=$(ls *.h | wc -l)
		h_in_sub=$(ls */*.h | wc -l)
		if [[ $c_at_root -gt 0 ]]
		then
			if [[ $h_at_root -gt 0 ]]
			then
				if [[ $c_in_sub -gt 0 ]]
				then
					if [[ $h_in_sub -gt 0 ]]
					then
						scan-build gcc -Wall -Wextra -Werror *.c */*.c *.h */*.h
					else
						scan-build gcc -Wall -Wextra -Werror *.c */*.c *.h
					fi
				else
					scan-build gcc -Wall -Wextra -Werror *.c *.h
				fi
			elif [[ $c_in_sub -gt 0 ]]
			then
				if [[ $h_in_sub -gt 0 ]]
				then
					scan-build gcc -Wall -Wextra -Werror *.c */*.c */*.h
				else
					scan-build gcc -Wall -Wextra -Werror *.c */*.c
				fi
			else
				scan-build gcc -Wall -Wextra -Werror *.c
			fi
		else
			echo $RED"nothing to compile"$RST
		fi
	fi
	if [[ $compile -eq 1 ]]
	then
		scan-view "/tmp/$(ls -lt /tmp/ | grep "scan-build" --color=never | head -1 | awk '{print $9}')"
	fi
}

function print_title()
{
	escp="\e["
	wrt=";3"
	echo -e $escp"2"$wrt$2"m>"$escp"0"$wrt$2"m>"$escp"1"$wrt$2"m>" $1 $escp"1"$wrt$2"m<"$escp"0"$wrt$2"m<"$escp"2"$wrt$2"m<$RST"
	# echo -e "\e[2;3$2m"">""\e[0;3$2m"">""\e[1;3$2m"">" $1 "\e[1;3$2m""<""\e[0;3$2m""<""\e[2;3$2m""<$RST"

}

function search()
{
	if [ -z "$  1" ]; then
		echo "first arg missing"
	else
		grep -riIn -B 4 $1
		if [[ $(grep -riIon $1 | wc -l) == 1 ]]; then
			a="$(grep -riIon $1 | sed -r "s/\x1B\[([0-9]{1,3}(;[0-9]{1,2})?)?[mGK]//g" | awk -F ":" '{print $1":"$2}')"
			code -g $a
		else
			echo -e $BACK_RED" $(grep -riIon $1 | wc -l) results, expected : 1 "$RST
			echo -e "\nsearch again for 1 result"
			echo -n "$> "
			read answer
			echo ""
			search $answer
			# b="$(tr -d \\033 $a :$1)"
			# echo -e $b
		fi
	fi
}

function split()
{
	if [[ $# == 0 ]]; then
		echo "Missing args, the first must be the string and the second will be the delimiter"
	elif [[ $# == 1 ]]; then
		text=$1
		IFS=' '
		read -a strarr <<< "$text"
		echo -e "length: ${#strarr[*]} \n"
		for val in "${strarr[@]}";
		do
			printf "$val\n"
		done
	elif [[ $# == 2 ]]; then
		text=$1
		IFS=$2
		read -a strarr <<< "$text"
		echo -e "length: ${#strarr[*]} \n"
		for val in "${strarr[@]}";
		do
			printf "$val\n"
		done
	fi
}

function size()
{
	# res=$(printf "%b" "$(sudo du -shc $(pwd)/* | sort -n)")
	# echo $res
	echo -e "size in $RED K $RST"
	sudo du -shc $(pwd)/* | sort -n | awk '{ if ($1 ~ /K/) {print $1,$2}}'
	echo
	echo -e "size in $RED M $RST"
	sudo du -shc $(pwd)/* | sort -n | awk '{ if ($1 ~ /M/) {print $1,$2}}'
	echo
	echo -e "size in $RED G $RST"
	sudo du -shc $(pwd)/* | sort -n | awk '{ if ($1 ~ /G/) {print $1,$2}}'
	echo
}

function norm_file()
{
	IFS=$'\n'
	toggle=1
	str=''
	array=( $(norminette $1 | grep Error! -A 1 --color=never) )
	for val in "${array[@]}"
	do
		if [[ $val != "--" ]]
		then
			echo $val
			if [[ $toggle == 1 ]]
			then
				str=$(echo -n $val | awk '{print $1}')
				# | tr 'Error!' ' '
				toggle=0
			else
				str+=$(echo $val | awk '{print $4}' | tr ',' ' ')
				toggle=1
				str=( $(echo $str | tr -d ' ') )
				code -g $str
				echo
			fi
		fi
	done
}

function new_norm_file()
{
	IFS=$'\n'
	toggle=2
	str=''
	glb=0
	array=( $(norminette $1 | grep Error! -A 2 --color=never) )
	for val in "${array[@]}"
	do
		if [[ $val != "--" ]]
		then
			if [[ $toggle == 2 ]]
			then
				echo $val
				str=$(echo -n $val | awk '{print $1}')
				# | tr 'Error!' ' '
				toggle=1
			elif [[ $toggle == 1 ]]
			then
				if echo $val | grep -q GLOBAL_VAR_DETECTED;
				then
					glb=1
				else
					echo $val
					str+=$(echo $val | awk '{print $4}' | tr ',' ' ')
					str=( $(echo $str | tr -d ' ') )
					code -g $str
					echo
				fi
				toggle=0

			else
				if [[ $glb == 1 ]]
				then
					echo $val
					str+=$(echo $val | awk '{print $4}' | tr ',' ' ')
					toggle=0
					str=( $(echo $str | tr -d ' ') )
					code -g $str
					echo
					glb=0
				fi
				toggle=2
			fi
		fi
	done
}

function pyramid()
{
	# echo -e "requirement:"
	# echo -e " download egypt, extract and cd into the egypt folder"
	# echo -e " perl Makefile.PL"
	# echo -e " sudo make install"
	# echo -e " install graphviz"
	# echo -e ""
	# echo -e "cmd:"
	# echo -e "make CFLAGS=-fdump-rtl-expand"
	# echo -e "egypt $(find . -name '*.expand' -print) | dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o ./call"
	# make CFLAGS=
	echo "in makefile: -fdump-rtl-expand"
	# make fclean
	make CFLAGS=-fdump-rtl-expand
	egypt $(find . -name '*.expand' -print) > call.dot
	sed -i '/mlx/s/\(.*\[\)\([^]]*\)\(].*\)/\1\2 style=filled fontcolor=black fillcolor=gray\3/' call.dot
	dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o call.png call.dot
	# egypt $(find . -name '*.expand' -print) | dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o ./call.png
}

function pharaoh()
{
	make fclean
	code call.dot

	make CFLAGS=-fdump-rtl-expand
	egypt $(find . -name '*.expand' -print) > call.dot
	sed -i '/mlx/s/\(.*\[\)\([^]]*\)\(].*\)/\1\2 style=filled fontcolor=black fillcolor=gray\3/' call.dot
	sed -i '/init_/s/\(.*\[\)\([^]]*\)\(].*\)/\1\2 style=filled fontcolor=black fillcolor=lightblue\3/' call.dot
	dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o call.png call.dot

	# cd minilibx
	# make
	# cd ..

	make CFLAGS=-fdump-rtl-expand
	egypt $(find . -name '*.expand' -print) > call.dot
	sed -i '/mlx/s/\(.*\[\)\([^]]*\)\(].*\)/\1\2 style=filled fontcolor=black fillcolor=gray\3/' call.dot
	sed -i '/init_/s/\(.*\[\)\([^]]*\)\(].*\)/\1\2 style=filled fontcolor=black fillcolor=lightblue\3/' call.dot
	# graph [bgcolor=black fontcolor=white];
	# node [bgcolor=black fontcolor=white color=white];
	# edge [color=white];
	dot -Gsize=3000,3000 -Grankdir=LR -Tpng -o call.png call.dot

	code call.png
}

function where_cfg()
{
	SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )
	echo $SCRIPT_DIR
}

function ffd()
{
	file="$(basename $PWD).c"
	touch $file && code $file
}

function date_man()
{
	man date | head -144 | tail -n 92
}

function kill_task()
{
	if [[ $# == 1 ]]
	then
		IFS=$'\n'
		res=($(top -bn1 | grep -i $1))
		for val in ${res[@]}
		do
			echo $val
		done
	else
		echo -e $W_ARGS
	fi
}

function end()
{
	date;
	# git status;
	sleep 0.5;
	pkill --oldest chrome;
	sleep 0.5;
	pkill --oldest chrome;
	sleep 0.5;
	pkill --oldest Discord;
	sleep 0.5;
	pkill -SIGKILL -u $USER;
	sleep 0.5;
	pkill --newest code;
	sleep 0.5;
	pkill --oldest code;
	sleep 0.5;
	pkill --oldest bash;
	sleep 0.5;
	pkill --oldest bash;
	sleep 0.5;
	pkill --oldest bash;
}

function end_work()
{
	if [[ $# == 0 ]]; then
		echo "missing arg(s)";
	else
		message="$1"
		make fclean
		cd ~/42/.
		date
		git status
		echo
		echo -e $BOLD_BLACK$BACK_GREEN" Poush $RESET$BOLD_WHITE $1"$RESET
		echo
		sleep 2
		if git add . 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong : git add ."$RST
			return 0;
		fi
		echo -e $CYAN"stop"$RST
		git commit -m $message
		if git push 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong with $BOLD_RED git push"$RST
			return 0;
		fi
		echo
		echo -e $BOLD_BLACK$BACK_GREEN" End poush $RESET$BOLD_WHITE $1"$RESET
		echo
		git status
		sleep 0.5
		pkill --oldest chrome
		sleep 0.5
		pkill --oldest chrome
		sleep 0.5
		pkill --oldest Discord
		sleep 0.5
		pkill -SIGKILL -u $USER
		sleep 0.5
		pkill --oldest bash
		sleep 0.5
		pkill --oldest bash
		sleep 0.5
		pkill --oldest bash
		sleep 0.5
		pkill --oldest obs
		sleep 0.5
		pkill --oldest obsidian
		sleep 0.5
		pkill --newest code
		sleep 0.5
		pkill --oldest codev
	fi
}

function act()
{
	cd ~/42/cursus/$1
}

complete -W "$(ls ~/42/cursus/)" act
# complete -W "$(ls ~/42/cursus/*/*)" act

function complt()
{
	arr=$(ls -d ~/42/cursus/*/*/*)
	# echo $arr
	for var in $arr
	do
		echo $var | sed "s|$HOME/42/cursus/||"
	done

	# subfolder completion
}

function work()
{
	if [ -z $1 ]; then
		echo "first arg missing";
	else
		cd;
		cd 42;
		git pull;
		cd ~/42/cursus/$1 && code . && sleep 3 && google-chrome;
	fi
}

function brgt()
{
	LEVEL=$1;
	if [[ $LEVEL -gt 100 ]]; then
		echo -e $SYNTAX;
		exit 1;
	fi;
	if [[ $LEVEL -lt 0 ]]; then
		echo -e $SYNTAX;
		exit 1;
	fi;
	brightness_level="$(( LEVEL / 100 )).$(( LEVEL % 100 ))";
	screenname=$(xrandr | grep " connected" | cut -f1 -d" ");
	echo "$(xrandr --output $screenname --brightness $brightness_level)"
}

function low()
{
	if [[ $1 == "clr" ]]; then
		xrandr --output HDMI-2 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-1 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-2 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-3 --gamma 1:1:1 --brightness 0.5 || xrandr --output DP-4 --gamma 1:1:1 --brightness 0.5;
	else
		xrandr --output HDMI-2 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-1 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-2 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-3 --gamma 1:0.8:0.6 --brightness 0.5 || xrandr --output DP-4 --gamma 1:0.8:0.6 --brightness 0.5;
	fi
}

function mid()
{
	if [[ $1 == "clr" ]]; then
		xrandr --output HDMI-2 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-1 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-2 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-3 --gamma 1:1:1 --brightness 0.7 || xrandr --output DP-4 --gamma 1:1:1 --brightness 0.7;
	else
		xrandr --output HDMI-2 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-1 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-2 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-3 --gamma 1:0.8:0.6 --brightness 0.7 || xrandr --output DP-4 --gamma 1:0.8:0.6 --brightness 0.7;
	fi
}

function high()
{
	if [[ $1 == "clr" ]]; then
		xrandr --output HDMI-2 --gamma 1:1:1 --brightness 1 || xrandr --output DP-1 --gamma 1:1:1 --brightness 1 || xrandr --output DP-2 --gamma 1:1:1 --brightness 1 || xrandr --output DP-3 --gamma 1:1:1 --brightness 1 || xrandr --output DP-4 --gamma 1:1:1 --brightness 0.9;
	else
		xrandr --output HDMI-2 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-1 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-2 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-3 --gamma 1:0.8:0.6 --brightness 1 || xrandr --output DP-4 --gamma 1:0.8:0.6 --brightness 0.9;
	fi
}

function commit()
{
	if [[ $# == 0 ]]; then
		echo "missing arg(s)";
	else
		message="$1";
		date;
		save=$(pwd)
		git status;
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" Commit $RESET$BOLD_WHITE $1"$RESET;
		echo;
		sleep 2;
		if git add . 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong : git add ."$RST
			return 0;
		fi
		echo -e $CYAN"stop"$RST
		git commit -m $message
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" End Commit $RESET$BOLD_WHITE $1"$RESET;
		echo;
		git status;
		cd $save
	fi
}

function endlate()
{
	if [[ $# == 0 ]]; then
		echo "missing arg(s)";
	else
		message="$1";
		make fclean
		cd ~/42/.
		date;
		git status;
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" Poush $RESET$BOLD_WHITE $1"$RESET;
		echo;
		sleep 1.5;
		if git add . 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong : git add ."$RST
			git add .
			return 0;
		fi
		git commit -m $message
		if git push 2>&1 | grep -iqo denied --color=never
		then
			echo -e $RED"something wrong with $BOLD_RED git push"$RST
			git push
			return 0;
		fi
		echo;
		echo -e $BOLD_BLACK$BACK_GREEN" End poush $RESET$BOLD_WHITE $1"$RESET;
		echo;
		git status;
		sleep 0.25;
		pkill --oldest chrome;
		sleep 0.25;
		pkill --oldest chrome;
		sleep 0.25;
		pkill --oldest Discord;
		sleep 0.25;
		pkill -SIGKILL -u $USER
		sleep 0.25
		pkill --oldest bash;
		sleep 0.25;
		pkill --oldest bash;
		sleep 0.25;
		pkill --oldest bash;
		sleep 0.25;
		pkill --oldest gnome-shell;
		sleep 0.25;
		pkill --oldest code;
	fi
}

function select_option() {

	# little helpers for terminal print control and key input
	ESC=$( printf "\033")
	cursor_blink_on()  { printf "$ESC[?25h"; }
	cursor_blink_off() { printf "$ESC[?25l"; }
	cursor_to()        { printf "$ESC[$1;${2:-1}H"; }
	print_option()     { printf "   $1 "; }
	print_selected()   { printf "  $ESC[7m $1 $ESC[27m"; }
	get_cursor_row()   { IFS=';' read -sdR -p $'\E[6n' ROW COL; echo ${ROW#*[}; }
	key_input()        { read -s -n3 key 2>/dev/null >&2
						if [[ $key = $ESC[A ]]; then echo up;    fi
						if [[ $key = $ESC[B ]]; then echo down;  fi
						if [[ $key = ""     ]]; then echo enter; fi; }

	# initially print empty new lines (scroll down if at bottom of screen)
	for opt; do printf "\n"; done

	# determine current screen position for overwriting the options
	local lastrow=`get_cursor_row`
	local startrow=$(($lastrow - $#))

	# ensure cursor and input echoing back on upon a ctrl+c during read -s
	trap "cursor_blink_on; stty echo; printf '\n'; exit" 2
	cursor_blink_off

	local selected=0
	while true; do
		# print options by overwriting the last lines
		local idx=0
		for opt; do
			cursor_to $(($startrow + $idx))
			if [ $idx -eq $selected ]; then
				print_selected "$opt"
			else
				print_option "$opt"
			fi
			((idx++))
		done

		# user key control
		case `key_input` in
			enter) break;;
			up)    ((selected--));
				if [ $selected -lt 0 ]; then selected=$(($# - 1)); fi;;
			down)  ((selected++));
				if [ $selected -ge $# ]; then selected=0; fi;;
		esac
	done

	# cursor position back to normal
	cursor_to $lastrow
	printf "\n"
	cursor_blink_on

	return $selected
}

function msearch()
{
	if [[ $# == 1 ]]
	then
		IFS='\n'
		res=$(grep -rion $1 --exclude-dir=".git" --color=never --binary-files=without-match)
		res=($res)

		echo ${#res[@]}
		if [[ $(echo ${res[@]} | wc -l) -eq 1 ]]
		then
			echo -e "do you want to open this file $GREEN$(echo $res | awk -F ':' '{print $1}')$RST at line $GREEN$(echo $res | awk -F ':' '{print $2}')$RST ? (y/n)"
			read answer
			if [[ $answer == "y" ]]
			then
				code -g "$(echo $res | awk -F ':' '{print $1":"$2}')"
			else
				echo $NOTHING
			fi
		else
			# echo "multiple"
			echo "Select file and line:"
			echo
			select_option "${res[@]}"
			choice=$?

			echo "Choosen index = $choice"
			echo "        value = ${options[$choice]}"
		fi

		# source ~/.bashrc
		# sleep 1.5
		# clear
		# msearch parsi
	else
		echo -e $W_ARGS
	fi
}


# IFS=$'\n'
# for f in $(declare -F); do
# 	echo "${f:11}"
# done
# launch bash without bashrc

export DEBUGINFOD_URLS="https://debuginfod.archlinux.org/"